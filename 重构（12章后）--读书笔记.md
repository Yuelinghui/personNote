##大型重构

之所以进行重构，必定是为了达到某个目的，而不仅仅是为了看起来有所动作！

大型重构，会消耗相当长的时间。若需要给一个运行中的系统添加功能，不可能把系统停止运行两个月进行重构，只能一点一点地做重构的工作，今天一点点，明天一点点。

应该根据需要安排自己的工作，只在需要添加新功能或修补错误时才进行重构。不必一开始就完成整个系统的重构，重构程度只要能满足其他任务的需要就行了。

大型重构为许许多多的修改指定了方向，整个团队都必须意识到：有一个大型重构正在进行，每个人都应该相应地安排自己的行动。

之所以需要重构，不是因为好玩，而是因为希望重构能对程序有所帮助，让我们能够做一些重构之前无法做的事情

###Tease Apart Inheritance（梳理并分解继承体系）

某个继承体系同时承担两项责任，建立两个继承体系，并通过委托关系让其中一个可以调用另一个

####动机

混乱的继承体系是一个严重的问题，因为它会导致重复代码，它还会使修改变得困难，因为特定问题的解决策略被分散到了整个继承体系。最终，代码将非常难以理解

若继承体系中的某一特定层级上的所有类，其子类名称都以相同的形容词开始，那么这个体系很可能就是承担着两项不同的责任

####做法

* 识别出继承体系所承担的不同责任，然后建立一个二维表格，并以坐标轴标示出不同的任务
* 判断哪一项责任更重要些，并准备将它留在当前的继承体系中。准备将另一项责任移到另一个继承体系中
* 从当前的超类提炼出一个新类，用以标示重要性稍低的责任，并在原超类中添加一个实例变量，用以保存新类的实例
* 对应于原继承体系中的每个子类，创建新类的一个子类。在原继承体系的子类中，将前一步所添加的实例变量初始化为新建子类的实例
* 将原继承体系中的行为搬移到与之对应的新建继承体系中
* 当原继承体系中的某个子类不再有任何代码时，就将它去除
* 重复上述步骤，直到原继承体系中的所有子类都被处理为止

###Convert Procedural Design to Objects（将过程化设计转化为对象设计）

有一些传统过程化风格的代码，将数据记录变为对象，将大块的行为分成小块，并将行为移入相关对象中

