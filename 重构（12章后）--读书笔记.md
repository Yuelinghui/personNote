##大型重构

之所以进行重构，必定是为了达到某个目的，而不仅仅是为了看起来有所动作！

大型重构，会消耗相当长的时间。若需要给一个运行中的系统添加功能，不可能把系统停止运行两个月进行重构，只能一点一点地做重构的工作，今天一点点，明天一点点。

应该根据需要安排自己的工作，只在需要添加新功能或修补错误时才进行重构。不必一开始就完成整个系统的重构，重构程度只要能满足其他任务的需要就行了。

大型重构为许许多多的修改指定了方向，整个团队都必须意识到：有一个大型重构正在进行，每个人都应该相应地安排自己的行动。

之所以需要重构，不是因为好玩，而是因为希望重构能对程序有所帮助，让我们能够做一些重构之前无法做的事情

###Tease Apart Inheritance（梳理并分解继承体系）

某个继承体系同时承担两项责任，建立两个继承体系，并通过委托关系让其中一个可以调用另一个

####动机

混乱的继承体系是一个严重的问题，因为它会导致重复代码，它还会使修改变得困难，因为特定问题的解决策略被分散到了整个继承体系。最终，代码将非常难以理解

若继承体系中的某一特定层级上的所有类，其子类名称都以相同的形容词开始，那么这个体系很可能就是承担着两项不同的责任

####做法

* 识别出继承体系所承担的不同责任，然后建立一个二维表格，并以坐标轴标示出不同的任务
* 判断哪一项责任更重要些，并准备将它留在当前的继承体系中。准备将另一项责任移到另一个继承体系中
* 从当前的超类提炼出一个新类，用以标示重要性稍低的责任，并在原超类中添加一个实例变量，用以保存新类的实例
* 对应于原继承体系中的每个子类，创建新类的一个子类。在原继承体系的子类中，将前一步所添加的实例变量初始化为新建子类的实例
* 将原继承体系中的行为搬移到与之对应的新建继承体系中
* 当原继承体系中的某个子类不再有任何代码时，就将它去除
* 重复上述步骤，直到原继承体系中的所有子类都被处理为止

###Convert Procedural Design to Objects（将过程化设计转化为对象设计）

有一些传统过程化风格的代码，将数据记录变为对象，将大块的行为分成小块，并将行为移入相关对象中

####做法

* 针对每一个记录类型，将其转变为只含访问函数的哑数据对象
* 针对每一处过程化风格，将该处代码提炼到一个独立类中
* 针对每一段长长的程序，将其分解，将分解后的函数分别移到它所相关的哑数据类中
* 重复上述步骤，直到原始类中的所有函数都被移除

###Separate Domain from Presentation（将领域和表述/显示分离）

某系GUI类中包含了领域逻辑，将领域逻辑分离出来，为它们建立独立的领域类

####动机

MVC模式最核心的价值在于：它将用户界面代码和领域逻辑（即模型）分离。展现类只含用以处理用户界面的逻辑；领域类不含任何与程序外观相关的代码，只含业务逻辑相关代码

####做法

* 为每个窗口建立一个领域类
* 若窗口内有一张表格，新建一个类来表示其中的行，再以对应的领域类中的一个集合来容纳所有的行领域对象
* 检查窗口中的数据，若数据只被用于UI，就把它留着；若数据被领域逻辑使用，而且不显示与窗口上，将它搬移到领域类中；若数据同时被UI和领域逻辑使用，使它同时存在于两处，并保持两处之间的同步
* 检查展现类中的逻辑，将展现逻辑从领域逻辑中分开，将领域逻辑移到领域类中
* 最后拥有两组彼此分离的类

###Extract Hierarchy（提炼继承体系）

某个类做了太多工作，其中一部分以大量条件表达式完成，建立继承体系，以子类来表示各种情况

####动机

遇到“瑞士军刀”类，就需要一个好策略，将它的各个功能梳理并分开。只有条件逻辑在对象的整个生命周期保持不变才可以

####做法

