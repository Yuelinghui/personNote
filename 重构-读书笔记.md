#重构改善既有代码的设计

##什么是重构

所谓重构（refactoring）是一个过程：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。本质上，重构就是在代码写好之后改进它的设计。

##重构，第一个案例

###重构的第一步

为即将修改的代码建立一组可靠的测试环境，这些测试时必要的。好的测试时重构的根本，花时间建立一个优良的测试机制是完全值得的，因为当你修改程序时，好测试会提供必要的安全保障。

首先，在代码里找出函数内的局部变量和参数。任何不会被修改的变量都可以被当作参数传入新的函数，至于会被修改的变量就需格外小心。如果只有一个变量会被修改，可以把它当作返回值。

重构步骤的本质：由于每次修改的幅度都很小，所以任何错误都很容易发现。**重构技术就是以微小的步伐修改程序，如果出现bug，很容易便可发现它。**

更改变量名称是值得的行为！！好的代码应该清楚表达出自己的功能，变量名称是代码清晰的关键。**任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。**

观察函数，把它放到正确的位置。**绝大多数情况下，函数应该放在它所使用的数据的所属对象内。**

去掉旧函数，有时候会保留旧函数，让它调用新函数，如果旧函数是一个public函数，而我又不想修改其他类的接口，这便是一种有用的手法。

尽量出去赋值后就不再改变的临时变量。临时变量往往引发问题，它们会导致大量参数被传来传去，而其实完全没有这种必要。**我们很容易跟丢它们，尤其在长长的函数中更是如此。当然这么做需付出性能上的代价，但这很容易在其他的地方被优化。**

最好不要在另一个对象的属性基础上运用switch语句，**如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用**

使用**多态**来解决switch的使用情况！

##重构原则

###何谓重构
1. 名词形式：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
2. 动词形式：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

重构的目的是使软件更容易被理解和修改。可以在软件内部做很多修改，但必须对软件可观察的外部行为只造成很小变化，或甚至不造成变化。与之形成对比的是性能优化，和重构一样，性能优化通常不会改变组件的行为（除了执行速度），只会改变其内部结构。但是两者出发点不同：性能优化往往使代码较难理解，但为了得到所需的性能你不得不那么做。

####两顶帽子

使用重构技术开发软件时，你把自己的时间分配给两种截然不同的行为：
1. 添加新功能。你不应该修改既有代码，只管添加新功能
2. 重构。不能再添加功能，只管改进程序结构。

软件开发中，可能经常变换帽子，但是无论何时你都应该清楚自己戴的是哪一顶帽子。

###为何重构

####重构改进软件设计

没有重构，程序的设计会逐渐腐败变质。贸然修改代码，程序会逐渐失去自己的结果，程序员越来越难以通过阅读源码而理解原来的设计。

重构很像是在整理代码。代码结果的流失是积累性的，越难看出代码的设计意图，就越难保护其中的设计。经常性的重构可以帮助代码维持自己该有的形态。

改进设计的一个重要方向就是消除重复代码。这个动作的重要性在于方便未来的修改。代码量减少将使未来可能的程序修改动作容易的多。

####重构使软件更容易理解

重构可以帮助我们让代码更易读，让代码更好地表达自己的用途。

可以利用重构来协助我们理解不熟悉的代码。动手修改代码，让它更好地反映出自己的理解，然后重新执行，看它是否仍然正常运作，以此检验自己的理解是否正确。

研究代码时，重构可以把自己带到更高的理解层次上。

####重构帮忙找到bug

对代码的理解，可以帮助我们找到bug。如果对代码进行重构，我们可以深入理解代码的作为，并恰到好处地把新的理解反馈回去。搞清楚程序结构的同时，我们也清楚了自己所做的一些假设，能够轻松找到bug。

####重构提高编程速度

重构可以帮助我们更快速地开发程序。

重构能够提高代码质量，改善设计，提升可读性，减少错误。良好的设计是快速开发的根本，拥有良好设计才可能做到快速开发。

良好设计是维持软件开发速度的根本，重构可以帮助我们更快速地开发软件，阻止系统腐败变质，甚至还可以提高设计质量。

###何时重构

反对专门拨出时间进行重构！重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地进行，不应该为重构而重构。

####三次法则

第一次做某件事只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，就应该重构。

**事不过三，三则重构**

####添加功能时重构

最常见的重构时间就是我们想给软件添加新特性的时候。直接原因是为了帮助我们理解需要修改的代码。另一个原因是代码的设计无法帮助我轻松添加我所需要的特性。

**重构是一个快速流畅的过程，一旦完成重构，新特性的添加就会更快速，更流畅。**

####修改错误时重构

调试过程中运用重构，多半是为了让代码更具可读性。

####复审代码时重构

代码复审有助于在开发团队中传播知识，也让更多人有机会提出有用的建议。

重构可以帮助自己复审别人的代码。重构还可以帮助代码复审工作得到更具体的结果。

“结对编程”的形式，把代码复审的积极性发挥到了极致。在开发过程中形成随时进行的代码复审工作，而重构也就包含在开发过程内了。

####间接层和重构

重构往往把大型对象拆成多个小型对象，把大型函数拆成多个小型函数。但是，间接层是一柄双刃剑。间接层有它的价值：
* 允许逻辑共享。比如父类中的某个函数被所有子类共享。
* 分开解释意图和实现。选择每个类和函数的名字，给了我们一个解释自己意图的机会，类或函数内部则解释实现这个意图的做法。以更小单元的意图来编写，可以描述其结构中的大部分重要信息。
* 隔离变换。在两个不同地点使用同一对象，其中一个地点想改变对象行为，如果修改就要冒同事影响两处的风险。为此可以做出一个子类，并在需要修改处引用这个子类。
* 封装条件逻辑。多态消息，可以灵活而清晰地表达条件逻辑，将条件逻辑转化为消息形式，能降低代码的重复，增加清晰度并提高弹性、

重构游戏：在保持系统现有行为的前提下，如果才能提高系统的质量或降低其成本，从而使它更有价值。

还有一种比较少见的重构游戏：找出不值得的间接层，并将它拿掉。

###重构的难题

虽然我们坚决认为应该尝试一下重构，获得它所提供的利益，但与此同时，我们也应该时时监控其过程，注意寻找重构可能引入的问题。

####数据库

重构经常出问题的一个领域就是数据库，绝大多数程序都与背后的数据库结构紧密耦合在一起。另一个原因是数据迁移。

对非对象数据库，解决办法之一就是：**在对象模型和数据库模型之间插入一个分隔层，隔离两个模型各自的变化。**

####修改接口

分开修改软件模块的实现和接口，安全地修改对象内部实现而不影响他人，但对于接口要谨慎。

面对已发布接口（published interface），无法仅仅修改调用者而能够安全地修改接口。需要一个更复杂的流程。

如果重构手法改变了已发布接口，必须同时维护新旧两个接口，直到所有用户都有时间对这个变化做出反应。让旧接口调用新接口，千万不要复制函数实现。还应该使用deprecation设施，将旧接口标记为deprecated。

另一个选择就是**不要发布接口，**当然不是完全禁止。

**不要过早发布接口，修改代码所有权政策，使重构更顺畅。**

####难以通过重构手法完成的设计改动

的确也有难以重构的地方，比如说在一个项目中，我们很难将不考虑安全性需求时构造起来的系统重构为具有良好安全性的系统。

遇到这种情况，先想象重构的情况，考虑候选设计方案，选最简单的设计，哪怕不能覆盖所有潜在需求。

####何时不该重构

有时候根本不应该重构，比如既有代码实在太混了，重构还不如重新写来的简单。

重写而非重构的一个清楚讯号就是：**现有代码根本不能正常运作，只是试着做点测试，就发现代码中满是错误，根本步伐稳定运作。**

**重构之前，代码必须起码能够在大部分情况下正常运作。**

折中的办法就是：将“大块头软件”重构为封装良好的小型组件。然后可以逐一对组件做出“重构或重建”的决定。

另外，如果项目已近最后期限，我们也应该避免重构，因为已经没有时间了。

重构的确能够提高生产力，如果最后没有足够时间，通常就表示其实早该进行重构。

###重构与设计

**重构和设计彼此互补！**

做预先设计，但不必一定找出正确的解决方案，只需要得到一个足够合理的解决方案就够了。之后察觉最佳解决方案和当初设想的有些不同就使用重构。

重构可以带来更简单的设计，同时又不损失灵活性，这降低了设计过程的难度，减轻了设计压力。

**劳而无获--哪怕完全了解系统，也请实际度量它的性能，不要臆测，臆测会让你学到一些东西，但十有八九是错的。**

###重构与性能

重构可能使软件运行更慢，但它也使软件的性能优化更容易。首先写出可调的软件，然后调整它以求获取足够速度。

* 时间预算法。分解设计时做好预算，给每个组件预先分配一定资源，包括时间和执行轨迹。每个组件绝对不能超出自己的预算。
* 持续关注法。要求任何程序员在任何时间做任何事时，都要设法保持系统的高性能。
* 系能提升法。编写构造良好的程序，不对性能投以特别的关注，直至进入性能优化阶段，再按照某个特定程序来调整程序性能。

在性能优化阶段，首先用一个度量工具来监控程序，找出哪些地方大量消耗时间和空间，然后集中关注这些性能热点，并使用持续关注法来优化它们。

一个构造良好的程序可从两方面帮助这一优化形式
1. 有比较充裕的时间进行性能调整。有更多时间用在性能问题上。
2. 进行性能分析时有较细的粒度，于是度量工具把你带入范围较小的程序段落中，而性能的调整也比较容易些。

重构可以帮助我们写出更快的软件。短期看来，重构的确可能使软件变慢，但它使优化阶段的软件性能调整更容易，最终还是会得到好的效果。

##代码的坏味道

###Duplicated Dode（重复代码）

坏味道行列中首当其冲的就是Duplicated Code，设法将它们合而为一，程序会变得更好。

* 同一个类的两个函数含有相同的表达式。提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。
* 两个互为兄弟的子类内含相同表达式。提炼出重复代码，将它推入超类内。若代码只是类似，并非完全相同，将相似部分和差异部分割开，构成单独一个函数。若有些函数以不同的算法做相同的事，选择其中较清晰的一个，并将其他函数的算法替换掉。
* 两个毫不相关的类，将重复代码提炼到一个独立类中，然后在另一个类内使用这个新类。但必须决定这个函数放在哪儿最合适，并确保它被安置后就不会再在其他任何地方出现。

###Long Method（过长函数）

应该更积极地分解函数。每当感觉需要以注释来说明点什么的时候，我们就需要把说明的东西放进一个独立函数中，并以其用途（而非实现手法）命名。

如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍。我们需要消除这些临时元素。

寻找注释。它们通常能指出代码用途和实现手法之间的语义距离。若代码前方有一行注释，就可以将这段代码替换成一个函数，并且可以在注释的基础上给这个函数命名。

条件表达式和循环常常也是提炼的信号。使用Decompose Conditional处理条件表达式。至于循环，应该将循环和其内的代码提炼到一个独立函数中。

###Large Class（过大的类）

将几个变量一起提炼至新类内。提炼时应该选择类内彼此相关的变量，将它们放在一起。

类内如果有太多代码，也是代码重复，混乱并最终走向死亡的源头。把多余的东西消弭于类内部。

一个类如果拥有太多代码，也适合使用扩展类和扩展接口。先确定客户端如何使用它们，然后为每一种使用方式提炼出一个接口。

###Long Parameter List（过长参数列）

如果你手上没有所需的东西，总可以叫另一个对象给你！因此，有了对象就不必把函数需要的所以东西都以参数传递给它了，只需传给它足够的，让函数能从中获得自己需要的东西就行了。

太长的参数列难以理解，太多参数会造成前后不一致，不易使用，而且一旦需要更多数据，就不得不修改它。若将对象传递给函数，大多数修改都将没有必要，因为很可能只需在函数内增加一两条请求，就能得到更多数据。

有时候明显不希望造成“被调用对象”与“较大对象”间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情合理。

###Divergent Change（发散式变化）

一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改，如果不能做到这点，就需要重构了。

若某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了。针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内所有内容都应该反应此变化。

###Shotgun Surgery（霰弹式修改）

若遇到某种变化，都必须在许多不同的类内做出许多小修改，如果需要修改的代码散步四处，不但很难找到它们，也很容易忘记某个重要的修改。

把所有需要修改的代码放进同一个类，若眼下没有合适的类可以安置这些代码，就创造一个。通常可以把一系列相关行为放进同一个类。

Divergent Change是指“一个类受多种变化的影响”，Shotgun Surgery则是指“一种变换引发多个类相应修改”。

###Feature Envy（依恋情结）

函数对某个类的兴趣高过对自己所处类的兴趣。这种情况最通常的焦点便是数据。某个函数为了计算某个值，从另一个对象那儿调用了很多的取值函数。把这个函数移至另一个地点。

判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起。先把这个函数分解为数个较小函数并分别放置于不同地点。

最根本的原则：**将总是一起变化的东西放置一块儿。数据和引用这些数据的行为总是一起变化的。如果例外出现，就搬移这些行为，保持变化只在一地发生。**

###Data Clumps（数据泥团）

两个类中相同的字段，许多函数签名中相同的参数，这些总是绑在一起出现的数据应该拥有属于它们自己的对象。

找出这些数据以字段形式出现的地方，将它们提炼到一个独立对象中。这么做的直接好处是可以将很多参数列缩短，简化函数调用。

**删掉众多数据中的一项，这么做，其他数据有没有因而失去意义？如果它们不再有意义，应该为它们产生一个新对象。**

###Primitive Obsession（基本类型偏执）

对象的一个极大的价值在于：**它们模糊（甚至打破）了横亘于基本数据和体积较大的类之间的界限。**

将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。在小任务上运用小对象！

###Switch Statements（switch惊悚现身）

**少用switch（或case）语句。从本质上说，switch语句的问题在于重复，常会发现同样的switch语句散布于不同地点，要为它添加一个新的case子句，就必须找到所有switch语句并修改它们。**

当看到switch语句，应该考虑以多态来替换它。

###Parallel Inheritance Hierarchies（平行继承体系）

每当为某个类增加一个子类，必须为另一个类相应增加一个子类。消除这种重复性的策略：让一个继承体系的实例引用另一个继承体系的实例。再运用Move Method和Move Field，就可以将引用端的继承体系消弭于无形。

###Lazy Class（冗赘类）

创建的每一个类，都得有人去理解它，维护它。如果一个类的所得不值其身价，就应该消失。

###Speculative Generality（夸夸其谈未来性）

如果你的某个抽象类其实没有太大作用，就消除它。如果所有设想都会被用到，就值得，如果用不到，就不值得。

###Temporary Field（令人迷惑的暂时字段）

其内某个实例变量仅为某种特定情况而设，这样的代码让人不易理解，因为通常认为对象在所有时候都需要它的所有变量。

为这个变量创建一个新类，并且把所有和这个变量相关的代码都放进这个新类。

###Message Chains（过度耦合的消息链）

使用消息链，意味着客户代码将于查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。

先观察消息链最终得到的对象是用来干什么的，把使用该对象的代码提炼到一个独立函数中，然后把这个函数推入消息链。

###Middle Man（中间人）

多度运用委托。某个类接口有一半的函数都委托给其他类，这样就是过度运用。这时应该去掉“中间人”，直接和真正负责的对象打交道。

###Inappropriate Intimacy（狎昵关系）

两个类过于亲密。过分狎昵的类必须拆散，帮它们划清界线，从而减少狎昵行径。如果两个类实在是情投意合，可以创建一个新类，把两者共同点提炼到一个安全地点，让它们使用这个新类。

继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。

###Alternative Classes with Different Interfaces（异曲同工的类）

如果两个函数做同一件事，却有着不同的签名，根据它们的用途重新命名。将某些行为移入类，直到两者的协议一致为止。

###Incomplete Library Class

复用常被视为对象的终极目的。类库构筑着没有未卜先知的能力，类库往往构造得不够好，而且往往不可能让我们修改其中的类使它完成我们希望完成的工作。

###Data Class（纯稚的数据类）

它们拥有一些字段，以及用于访问这些字段的函数。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细琐地操控着。应该将字段封装起来。

###Refused Bequest（被拒绝的遗赠）

子类应该继承超类的函数和数据，但是如果它们不想或不需要继承，又该咋办呢？按传统说法，这意味着继承体系设计错误。需要为这个子类新建一个兄弟类，把所有用不到的函数下推给那个兄弟，这样一来，超类就只持有所有子类共享的东西。但是，不建议这么做，起码不建议每次都这么做。

若子类复用了超类的行为，却又不愿意支持超类的接口，就不合适了。不愿意继承接口，也不要胡乱修改继承体系，把它从继承体系中移除。

###Comments（过多的注释）

看到一段代码有着很长的注释，然后发现这些注释之所以存在乃是因为代码很糟糕。

若需要注释来解释一段代码做了什么，不妨写一个新方法。若函数已经提炼出来，还需要注释，就给函数重命名。

**当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。**

##构筑测试体系

进行重构，首要前提就是拥有一个可靠的测试环境。

###自测代码的价值

**确保所有测试都完全自动化，让它们检查自己的测试结果。**

编写测试代码其实就是在问自己：添加这个功能需要做些什么。编写测试代码也能使你把注意力集中于接口而非实现。

频繁进行测试时极限编程的重要一环。如果你想重构，就必须编写测试代码。

Java中的测试惯用手法是testing main，每个类都应该有一个用于测试的main()。这是一个合理的习惯，但可能不好操控。

###JUnit测试框架

任何包含测试代码的类都必须继承测试框架所提供的TestCase类。

TestCase类提供两个函数专门准备测试数据
* setUp():用来产生相关对象
* tearDown():负责删除相关对象

**频繁地运行测试，每次编译请把测试也考虑进去--每天至少执行每个测试一次。**

除了捕捉失败，还可以捕捉错误。使用assertEquals()，assert()等;

####单元测试和功能测试

单元测试时高度局部化的东西，每个测试类都隶属于单一包。它能够测试其他包的接口，除此之外它将假设其他包一切正常。

功能测试用来保证软件能够正常运行。从客户的角度保障质量，并不关心程序员的生产力。

**每当收到bug报告，先写一个单元测试来暴露bug。**

###添加更多测试

**观察类该做的所有事情，然后针对任何一项功能的任何一种可能失败情况，进行测试。**

**测试你最担心出错的部分！**

考虑可能出错的边界条件，把测试火力集中在那儿。“寻找边界条件”也包括寻找特殊的，可能导致测试失败的情况。

**不要因为测试无法捕捉所有bug就不写测试，因为测试的确可以捕捉到大多数bug。**

##重构列表

###重构的记录格式
* 名称。建造一个重构词汇表，名称很重要。
* 简短概要。简单介绍此一重构手法的使用情景，以及它所做的事情
* 动机。“为什么需要这个重构”和“什么情况下不适用这个重构”
* 做法。简明介绍如果进行重构
* 范例。简单的例子说明

###寻找引用点

所有重构都要求我们找到对应某个函数，某个字段或某个类的所有引用点。

##重新组织函数

函数分解完毕后，就可以知道如何让它工作得更好，可能还会发现算法可以改进，从而使代码更清晰。

###Extract Method（提炼函数）

**将一段代码放进一个独立函数中，并让函数名称解释该函数的用途。**

####动机

看见一个过长的函数或者一段需要注释才能让人理解用途的代码，就将这段代码放进一个独立函数中。

* 每个函数的粒度都很小，那么函数被复用的机会就更大
* 这会使高层函数读起来就像一系列注释
* 如果函数都是细粒度，那么函数的覆写也会更容易

一个函数多长才算合适？长度不是问题，关键在于函数名称和函数本地之间的语义距离。

####做法

* 创造一个新函数，根据函数的意图来对它命名。（以“做什么”来命名，而不是以它“怎么做”命名）
* 将提炼出的代码从源函数复制到新建的目标函数中
* 仔细检查提炼出的代码，看看其中是否引用了“作用域限于源函数”的变量
* 检查是否有“仅用于被提炼代码段”的临时变量。若有，在目标函数中将它们声明为临时变量。
* 检查被提炼代码段，看看是否有任何局部变量的值被它改变。若一个临时变量值被修改，看看是否可以将提炼代码段处理为一个查询，并将结果赋值给相关变量。
* 将被提炼代码段中需要读取的局部变量，当做参数传给目标函数
* 处理完所有局部变量之后，进行编译。
* 在源函数中，将被提炼代码段替换为目标函数的调用。
* 编译，测试

####范例

* 无局部变量。直接提炼方法
* 有局部变量但是提炼出的代码只是读取这些变量的值，并不修改。将它们当做参数传给目标函数。
* 有局部变量并且提炼出的代码段会对它赋值。
    * 变量只在被提炼代码段中使用。将这个临时变量的声明移到被提炼代码段中。
    * 被提炼代码段之外的代码也使用这个变量。让目标函数返回该变量改变后的值。

###Inline Method(内联函数)

在函数调用点插入函数本地，然后移除该函数

####动机

手上有一群组织不甚合理的函数，将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数。

若使用了太多间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成在这些委托动作之间晕头转向，通常都会使用Inline Method。

####做法

* 检查函数，确定它不具多态性（**若子类继承了这个函数，就不要将此函数内联。**）
* 找出这个函数的所有被调用点
* 将这个函数的所有被调用点都替换为函数本体
* 编译，测试
* 删除该函数的定义

**如果遇到了复杂情况，就不应该使用这个重构手法**

###Inline Temp（内联临时变量）

将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。

####动机

唯一单独使用它的情况是：发现某个临时变量被赋予某个函数调用的返回值。一般这样的临时变量不会有任何危害，可以放心地把它留在那儿。但若这个临时变量妨碍了其他的重构手法，就应该将它内联化

####做法

* 检查给临时变量赋值的语句，确保等号右边的表达式没有副作用
* 如果这个临时变量并未被声明为final，那就将它声明为final，然后编译
* 找到该临时变量的所有引用点，将他们替换为表达式
* 每次修改后，编译并测试
* 修改完所有引用点之后，删除该临时变量的声明和赋值语句
* 编译，测试

###Replace Temp with Query（以查询取代临时变量）

临时变量保存某一表达式的运算结果，将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。

####动机

临时变量的问题在于：**它们是暂时的，而且只能在所属函数内使用**。如果把临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这份信息。

局部变量会是代码难以被提炼，所有应该尽可能把它们替换为查询式。

####做法

1. 简单情况

    * 找出被赋值一次的临时变量（若某个临时变量被赋值超过一次，考虑将它分割成多个变量）
    * 将该临时变量声明为final
    * 编译（确保该临时变量的确只被赋值一次）
    * 将对临时变量赋值的语句的等号右侧部分提炼到一个独立函数中。
    * 现将函数声明为private，日后根据情况放松对它的保护。确保提炼出来的函数无任何副作用（该函数并不修改任何对象内容）
    * 编译，测试
    * 在该临时变量身上实现Inline Temp

常常使用临时变量保存循环中的累加信息，这时，整个循环都可以被提炼为一个独立函数。有时，会在一个循环中累加好几个值，这时应该针对每个累加值重复一遍循环，将所有临时变量都替换为查询。

担心性能为题，不可不管它，若性能真的出了问题，也可以在优化时期解决它。

代码组织良好，往往能够发现更有效的优化方案：若没有进行重构，好的优化方案就可能与你失之交臂。

###Introduce Explaining Variable（引入解释性变量）

将复杂表达式（或其中一部分）的结果放进一个临时变量，一次变量名称来解释表达式用途

####动机

表达式有可能非常复杂而难以阅读，临时变量可以帮助我们将表达式分解为比较容易管理的形式

* 条件逻辑，将每个条件子句提炼出来，以一个良好命名的临时变量来解释对应条件子句的意义
* 在较长算法中，可以运用临时变量来解释每一步运算的意义

####做法

* 声明一个final临时变量，将待分解之复杂表达式中的一部分动作的运算结果赋值给它
* 将表达式中的“运算结果”这一部分，替换为上述临时变量
* 编译，测试
* 重复上述过程，处理表达式的其他部分

使用拓展函数来替换临时变量。

###Split Temporary Variable（分解临时变量）

某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。**针对每次赋值，创造一个独立，对应的临时变量**

####动机

循环变量会随循环的每次运行而改变；收集变量负责将整个函数的运算结果收集起来

除上述两种情况，若临时变量承担多个责任，就应该被替换（分解）为多个临时变量，每个变量只承担一个责任

####做法

* 在待分解临时变量的声明及其第一次被赋值处，修改其名称
* 将新的临时变量声明为final
* 以该临时变量的第二次赋值动作为界，修改此前对该临时变量的所有引用点，让它们引用新的临时变量
* 在第二次赋值处，重新声明原先那个临时变量
* 编译，测试
* 逐次重复上述过程。每次都在声明处对临时变量改名，并修改下次赋值之前的引用点

###Remove Assignments to Parameters（移除对参数的赋值）

代码对一个参数进行赋值，以一个临时变量取代该参数的位置

####动机

对于按值传递的情况，对参数的任何修改，都不会对调用端造成任何影响，按引用传递就会对引用对象造成影响

另外，参数表示被传递进来的，不要对参数赋值

####做法

* 建立一个临时变量，把待处理的参数值赋予它
* 以“对参数赋值”为界，将其后所有对此参数的引用点，全部替换为“对此临时变量的引用”
* 修改赋值语句，使其改为对新建之临时变量赋值
* 编译，测试

###Replace Method with Method Object（以函数对象取代函数）

大型函数，其中对局部变量的使用无法采用Extract method。将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后可以在同一个对象中将这个大型函数分解为多个小型函数

####动机

局部变量的存在会增加函数分解的难度，若一个函数中局部变量泛滥成灾，那么分解这个函数式非常困难的。有时候会发现无法拆解一个需要拆解的函数，使用函数对象

将所有局部变量都变成函数对象的字段，然后就可以对这个对象使用Extract Method创造出新函数，从而将原本的大型函数拆解变短

####做法

* 建立一个新类，根据待处理函数的用途，为这个类命名
* 在新类中建立一个final字段，用以保存原先大型函数所在的对象。针对原函数的每个临时变量和每个参数，在新类中建立一个对应的字段保存
* 新类的构造函数，接收源对象及原函数的所有参数作为参数
* 在新类中建立一个函数方法
* 将原函数的代码复制到新类的方法中
* 编译
* 将旧函数的函数本体替换为“创建新类后调用其中的函数”

###Substitute Algorithm（替换算法）

想要把某个算法替换为另一个更清晰的算法。将函数本体替换为另一个算法

####动机

做一件事可以有更清晰的方式，就应该以较清晰的方式取代复杂的方式。重构可以把一些复杂东西分解为较简单的小块，但有时必须壮士断腕，删掉整个算法，代之以较简单的算法

先确定自己已经尽可能分解了原先函数，替换一个巨大而复杂的算法是非常困难的，只有先将它分解为较简单的小型函数，然后才能有把握进行算法替换工作

####做法

* 准备好另一个替换用算法，让它通过编译
* 针对现有测试，执行上述的新算法，若结果与原本结果相同，重构结束
* 若测试结果不同，在测试和调试过程中，以旧算法为比较参照标准
* 对每个测试用例，分别以新旧两种算法执行，并观察两者结果是否相同

##在对象之间搬移特性

