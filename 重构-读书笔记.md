#重构改善既有代码的设计

##什么是重构

所谓重构（refactoring）是一个过程：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。本质上，重构就是在代码写好之后改进它的设计。

##重构，第一个案例

###重构的第一步

为即将修改的代码建立一组可靠的测试环境，这些测试时必要的。好的测试时重构的根本，花时间建立一个优良的测试机制是完全值得的，因为当你修改程序时，好测试会提供必要的安全保障。

首先，在代码里找出函数内的局部变量和参数。任何不会被修改的变量都可以被当作参数传入新的函数，至于会被修改的变量就需格外小心。如果只有一个变量会被修改，可以把它当作返回值。

重构步骤的本质：由于每次修改的幅度都很小，所以任何错误都很容易发现。**重构技术就是以微小的步伐修改程序，如果出现bug，很容易便可发现它。**

更改变量名称是值得的行为！！好的代码应该清楚表达出自己的功能，变量名称是代码清晰的关键。**任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。**

观察函数，把它放到正确的位置。**绝大多数情况下，函数应该放在它所使用的数据的所属对象内。**

去掉旧函数，有时候会保留旧函数，让它调用新函数，如果旧函数是一个public函数，而我又不想修改其他类的接口，这便是一种有用的手法。

尽量出去赋值后就不再改变的临时变量。临时变量往往引发问题，它们会导致大量参数被传来传去，而其实完全没有这种必要。**我们很容易跟丢它们，尤其在长长的函数中更是如此。当然这么做需付出性能上的代价，但这很容易在其他的地方被优化。**

最好不要在另一个对象的属性基础上运用switch语句，**如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用**

使用**多态**来解决switch的使用情况！

##重构原则

###何谓重构
1. 名词形式：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
2. 动词形式：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

重构的目的是使软件更容易被理解和修改。可以在软件内部做很多修改，但必须对软件可观察的外部行为只造成很小变化，或甚至不造成变化。与之形成对比的是性能优化，和重构一样，性能优化通常不会改变组件的行为（除了执行速度），只会改变其内部结构。但是两者出发点不同：性能优化往往使代码较难理解，但为了得到所需的性能你不得不那么做。

####两顶帽子

使用重构技术开发软件时，你把自己的时间分配给两种截然不同的行为：
1. 添加新功能。你不应该修改既有代码，只管添加新功能
2. 重构。不能再添加功能，只管改进程序结构。

软件开发中，可能经常变换帽子，但是无论何时你都应该清楚自己戴的是哪一顶帽子。

###为何重构

####重构改进软件设计

没有重构，程序的设计会逐渐腐败变质。贸然修改代码，程序会逐渐失去自己的结果，程序员越来越难以通过阅读源码而理解原来的设计。

重构很像是在整理代码。代码结果的流失是积累性的，越难看出代码的设计意图，就越难保护其中的设计。经常性的重构可以帮助代码维持自己该有的形态。

改进设计的一个重要方向就是消除重复代码。这个动作的重要性在于方便未来的修改。代码量减少将使未来可能的程序修改动作容易的多。

####重构使软件更容易理解

重构可以帮助我们让代码更易读，让代码更好地表达自己的用途。

可以利用重构来协助我们理解不熟悉的代码。动手修改代码，让它更好地反映出自己的理解，然后重新执行，看它是否仍然正常运作，以此检验自己的理解是否正确。

研究代码时，重构可以把自己带到更高的理解层次上。

####重构帮忙找到bug

对代码的理解，可以帮助我们找到bug。如果对代码进行重构，我们可以深入理解代码的作为，并恰到好处地把新的理解反馈回去。搞清楚程序结构的同时，我们也清楚了自己所做的一些假设，能够轻松找到bug。

####重构提高编程速度

重构可以帮助我们更快速地开发程序。

重构能够提高代码质量，改善设计，提升可读性，减少错误。良好的设计是快速开发的根本，拥有良好设计才可能做到快速开发。

良好设计是维持软件开发速度的根本，重构可以帮助我们更快速地开发软件，阻止系统腐败变质，甚至还可以提高设计质量。

###何时重构

反对专门拨出时间进行重构！重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地进行，不应该为重构而重构。

####三次法则

第一次做某件事只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，就应该重构。

**事不过三，三则重构**

####添加功能时重构

最常见的重构时间就是我们想给软件添加新特性的时候。直接原因是为了帮助我们理解需要修改的代码。另一个原因是代码的设计无法帮助我轻松添加我所需要的特性。

**重构是一个快速流畅的过程，一旦完成重构，新特性的添加就会更快速，更流畅。**

####修改错误时重构

调试过程中运用重构，多半是为了让代码更具可读性。

####复审代码时重构

代码复审有助于在开发团队中传播知识，也让更多人有机会提出有用的建议。

重构可以帮助自己复审别人的代码。重构还可以帮助代码复审工作得到更具体的结果。

“结对编程”的形式，把代码复审的积极性发挥到了极致。在开发过程中形成随时进行的代码复审工作，而重构也就包含在开发过程内了。

####间接层和重构

重构往往把大型对象拆成多个小型对象，把大型函数拆成多个小型函数。但是，间接层是一柄双刃剑。间接层有它的价值：
* 允许逻辑共享。比如父类中的某个函数被所有子类共享。
* 分开解释意图和实现。选择每个类和函数的名字，给了我们一个解释自己意图的机会，类或函数内部则解释实现这个意图的做法。以更小单元的意图来编写，可以描述其结构中的大部分重要信息。
* 隔离变换。在两个不同地点使用同一对象，其中一个地点想改变对象行为，如果修改就要冒同事影响两处的风险。为此可以做出一个子类，并在需要修改处引用这个子类。
* 封装条件逻辑。多态消息，可以灵活而清晰地表达条件逻辑，将条件逻辑转化为消息形式，能降低代码的重复，增加清晰度并提高弹性、

重构游戏：在保持系统现有行为的前提下，如果才能提高系统的质量或降低其成本，从而使它更有价值。

还有一种比较少见的重构游戏：找出不值得的间接层，并将它拿掉。

###重构的难题

虽然我们坚决认为应该尝试一下重构，获得它所提供的利益，但与此同时，我们也应该时时监控其过程，注意寻找重构可能引入的问题。

####数据库

重构经常出问题的一个领域就是数据库，绝大多数程序都与背后的数据库结构紧密耦合在一起。另一个原因是数据迁移。

对非对象数据库，解决办法之一就是：**在对象模型和数据库模型之间插入一个分隔层，隔离两个模型各自的变化。**

####修改接口

分开修改软件模块的实现和接口，安全地修改对象内部实现而不影响他人，但对于接口要谨慎。

面对已发布接口（published interface），无法仅仅修改调用者而能够安全地修改接口。需要一个更复杂的流程。

如果重构手法改变了已发布接口，必须同时维护新旧两个接口，直到所有用户都有时间对这个变化做出反应。让旧接口调用新接口，千万不要复制函数实现。还应该使用deprecation设施，将旧接口标记为deprecated。

另一个选择就是**不要发布接口，**当然不是完全禁止。

**不要过早发布接口，修改代码所有权政策，使重构更顺畅。**

####难以通过重构手法完成的设计改动

的确也有难以重构的地方，比如说在一个项目中，我们很难将不考虑安全性需求时构造起来的系统重构为具有良好安全性的系统。

遇到这种情况，先想象重构的情况，考虑候选设计方案，选最简单的设计，哪怕不能覆盖所有潜在需求。

####何时不该重构

有时候根本不应该重构，比如既有代码实在太混了，重构还不如重新写来的简单。

重写而非重构的一个清楚讯号就是：**现有代码根本不能正常运作，只是试着做点测试，就发现代码中满是错误，根本步伐稳定运作。**

**重构之前，代码必须起码能够在大部分情况下正常运作。**

折中的办法就是：将“大块头软件”重构为封装良好的小型组件。然后可以逐一对组件做出“重构或重建”的决定。

另外，如果项目已近最后期限，我们也应该避免重构，因为已经没有时间了。

重构的确能够提高生产力，如果最后没有足够时间，通常就表示其实早该进行重构。

###重构与设计

**重构和设计彼此互补！**

做预先设计，但不必一定找出正确的解决方案，只需要得到一个足够合理的解决方案就够了。之后察觉最佳解决方案和当初设想的有些不同就使用重构。

重构可以带来更简单的设计，同时又不损失灵活性，这降低了设计过程的难度，减轻了设计压力。

**劳而无获--哪怕完全了解系统，也请实际度量它的性能，不要臆测，臆测会让你学到一些东西，但十有八九是错的。**

###重构与性能

重构可能使软件运行更慢，但它也使软件的性能优化更容易。首先写出可调的软件，然后调整它以求获取足够速度。

* 时间预算法。分解设计时做好预算，给每个组件预先分配一定资源，包括时间和执行轨迹。每个组件绝对不能超出自己的预算。
* 持续关注法。要求任何程序员在任何时间做任何事时，都要设法保持系统的高性能。
* 系能提升法。编写构造良好的程序，不对性能投以特别的关注，直至进入性能优化阶段，再按照某个特定程序来调整程序性能。

在性能优化阶段，首先用一个度量工具来监控程序，找出哪些地方大量消耗时间和空间，然后集中关注这些性能热点，并使用持续关注法来优化它们。

一个构造良好的程序可从两方面帮助这一优化形式
1. 有比较充裕的时间进行性能调整。有更多时间用在性能问题上。
2. 进行性能分析时有较细的粒度，于是度量工具把你带入范围较小的程序段落中，而性能的调整也比较容易些。

重构可以帮助我们写出更快的软件。短期看来，重构的确可能使软件变慢，但它使优化阶段的软件性能调整更容易，最终还是会得到好的效果。

##代码的坏味道

###Duplicated Dode（重复代码）

坏味道行列中首当其冲的就是Duplicated Code，设法将它们合而为一，程序会变得更好。

* 同一个类的两个函数含有相同的表达式。提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。
* 两个互为兄弟的子类内含相同表达式。提炼出重复代码，将它推入超类内。若代码只是类似，并非完全相同，将相似部分和差异部分割开，构成单独一个函数。若有些函数以不同的算法做相同的事，选择其中较清晰的一个，并将其他函数的算法替换掉。
* 两个毫不相关的类，将重复代码提炼到一个独立类中，然后在另一个类内使用这个新类。但必须决定这个函数放在哪儿最合适，并确保它被安置后就不会再在其他任何地方出现。

###Long Method（过长函数）

应该更积极地分解函数。每当感觉需要以注释来说明点什么的时候，我们就需要把说明的东西放进一个独立函数中，并以其用途（而非实现手法）命名。

如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍。我们需要消除这些临时元素。

寻找注释。它们通常能指出代码用途和实现手法之间的语义距离。若代码前方有一行注释，就可以将这段代码替换成一个函数，并且可以在注释的基础上给这个函数命名。

条件表达式和循环常常也是提炼的信号。使用Decompose Conditional处理条件表达式。至于循环，应该将循环和其内的代码提炼到一个独立函数中。

###Large Class（过大的类）

将几个变量一起提炼至新类内。提炼时应该选择类内彼此相关的变量，将它们放在一起。

类内如果有太多代码，也是代码重复，混乱并最终走向死亡的源头。把多余的东西消弭于类内部。

一个类如果拥有太多代码，也适合使用扩展类和扩展接口。先确定客户端如何使用它们，然后为每一种使用方式提炼出一个接口。

###Long Parameter List（过长参数列）

如果你手上没有所需的东西，总可以叫另一个对象给你！因此，有了对象就不必把函数需要的所以东西都以参数传递给它了，只需传给它足够的，让函数能从中获得自己需要的东西就行了。

太长的参数列难以理解，太多参数会造成前后不一致，不易使用，而且一旦需要更多数据，就不得不修改它。若将对象传递给函数，大多数修改都将没有必要，因为很可能只需在函数内增加一两条请求，就能得到更多数据。

有时候明显不希望造成“被调用对象”与“较大对象”间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情合理。

###Divergent Change（发散式变化）

一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改，如果不能做到这点，就需要重构了。

若某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了。针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内所有内容都应该反应此变化。

###Shotgun Surgery（霰弹式修改）

若遇到某种变化，都必须在许多不同的类内做出许多小修改，如果需要修改的代码散步四处，不但很难找到它们，也很容易忘记某个重要的修改。

把所有需要修改的代码放进同一个类，若眼下没有合适的类可以安置这些代码，就创造一个。通常可以把一系列相关行为放进同一个类。

Divergent Change是指“一个类受多种变化的影响”，Shotgun Surgery则是指“一种变换引发多个类相应修改”。

###Feature Envy（依恋情结）

函数对某个类的兴趣高过对自己所处类的兴趣。这种情况最通常的焦点便是数据。某个函数为了计算某个值，从另一个对象那儿调用了很多的取值函数。把这个函数移至另一个地点。

判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起。先把这个函数分解为数个较小函数并分别放置于不同地点。

最根本的原则：**将总是一起变化的东西放置一块儿。数据和引用这些数据的行为总是一起变化的。如果例外出现，就搬移这些行为，保持变化只在一地发生。**

###Data Clumps（数据泥团）

两个类中相同的字段，许多函数签名中相同的参数，这些总是绑在一起出现的数据应该拥有属于它们自己的对象。

找出这些数据以字段形式出现的地方，将它们提炼到一个独立对象中。这么做的直接好处是可以将很多参数列缩短，简化函数调用。

**删掉众多数据中的一项，这么做，其他数据有没有因而失去意义？如果它们不再有意义，应该为它们产生一个新对象。**

###Primitive Obsession（基本类型偏执）

对象的一个极大的价值在于：**它们模糊（甚至打破）了横亘于基本数据和体积较大的类之间的界限。**

将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。在小任务上运用小对象！

###Switch Statements（switch惊悚现身）

**少用switch（或case）语句。从本质上说，switch语句的问题在于重复，常会发现同样的switch语句散布于不同地点，要为它添加一个新的case子句，就必须找到所有switch语句并修改它们。**

当看到switch语句，应该考虑以多态来替换它。

###Parallel Inheritance Hierarchies（平行继承体系）

每当为某个类增加一个子类，必须为另一个类相应增加一个子类。消除这种重复性的策略：让一个继承体系的实例引用另一个继承体系的实例。再运用Move Method和Move Field，就可以将引用端的继承体系消弭于无形。

###Lazy Class（冗赘类）

创建的每一个类，都得有人去理解它，维护它。如果一个类的所得不值其身价，就应该消失。