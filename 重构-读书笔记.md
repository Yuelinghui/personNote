#重构改善既有代码的设计

##什么是重构


所谓重构（refactoring）是一个过程：在不改变代码外在行为的前提下，对代码做出修改，以改进程序的内部结构。本质上，重构就是在代码写好之后改进它的设计。

##重构，第一个案例

###重构的第一步

为即将修改的代码建立一组可靠的测试环境，这些测试时必要的。好的测试时重构的根本，花时间建立一个优良的测试机制是完全值得的，因为当你修改程序时，好测试会提供必要的安全保障。

首先，在代码里找出函数内的局部变量和参数。任何不会被修改的变量都可以被当作参数传入新的函数，至于会被修改的变量就需格外小心。如果只有一个变量会被修改，可以把它当作返回值。

重构步骤的本质：由于每次修改的幅度都很小，所以任何错误都很容易发现。**重构技术就是以微小的步伐修改程序，如果出现bug，很容易便可发现它。**

更改变量名称是值得的行为！！好的代码应该清楚表达出自己的功能，变量名称是代码清晰的关键。**任何一个傻瓜都能写出计算机可以理解的代码。唯有写出人类容易理解的代码，才是优秀的程序员。**

观察函数，把它放到正确的位置。**绝大多数情况下，函数应该放在它所使用的数据的所属对象内。**

去掉旧函数，有时候会保留旧函数，让它调用新函数，如果旧函数是一个public函数，而我又不想修改其他类的接口，这便是一种有用的手法。

尽量出去赋值后就不再改变的临时变量。临时变量往往引发问题，它们会导致大量参数被传来传去，而其实完全没有这种必要。**我们很容易跟丢它们，尤其在长长的函数中更是如此。当然这么做需付出性能上的代价，但这很容易在其他的地方被优化。**

最好不要在另一个对象的属性基础上运用switch语句，**如果不得不使用，也应该在对象自己的数据上使用，而不是在别人的数据上使用**

使用**多态**来解决switch的使用情况！

##重构原则

###何谓重构
1. 名词形式：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
2. 动词形式：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

重构的目的是使软件更容易被理解和修改。可以在软件内部做很多修改，但必须对软件可观察的外部行为只造成很小变化，或甚至不造成变化。与之形成对比的是性能优化，和重构一样，性能优化通常不会改变组件的行为（除了执行速度），只会改变其内部结构。但是两者出发点不同：性能优化往往使代码较难理解，但为了得到所需的性能你不得不那么做。

####两顶帽子

使用重构技术开发软件时，你把自己的时间分配给两种截然不同的行为：
1. 添加新功能。你不应该修改既有代码，只管添加新功能
2. 重构。不能再添加功能，只管改进程序结构。

软件开发中，可能经常变换帽子，但是无论何时你都应该清楚自己戴的是哪一顶帽子。

###为何重构

####重构改进软件设计

没有重构，程序的设计会逐渐腐败变质。贸然修改代码，程序会逐渐失去自己的结果，程序员越来越难以通过阅读源码而理解原来的设计。

重构很像是在整理代码。代码结果的流失是积累性的，越难看出代码的设计意图，就越难保护其中的设计。经常性的重构可以帮助代码维持自己该有的形态。

改进设计的一个重要方向就是消除重复代码。这个动作的重要性在于方便未来的修改。代码量减少将使未来可能的程序修改动作容易的多。

####重构使软件更容易理解

重构可以帮助我们让代码更易读，让代码更好地表达自己的用途。

可以利用重构来协助我们理解不熟悉的代码。动手修改代码，让它更好地反映出自己的理解，然后重新执行，看它是否仍然正常运作，以此检验自己的理解是否正确。

研究代码时，重构可以把自己带到更高的理解层次上。

####重构帮忙找到bug

对代码的理解，可以帮助我们找到bug。如果对代码进行重构，我们可以深入理解代码的作为，并恰到好处地把新的理解反馈回去。搞清楚程序结构的同时，我们也清楚了自己所做的一些假设，能够轻松找到bug。

####重构提高编程速度

重构可以帮助我们更快速地开发程序。

重构能够提高代码质量，改善设计，提升可读性，减少错误。良好的设计是快速开发的根本，拥有良好设计才可能做到快速开发。

良好设计是维持软件开发速度的根本，重构可以帮助我们更快速地开发软件，阻止系统腐败变质，甚至还可以提高设计质量。

###何时重构

反对专门拨出时间进行重构！重构本来就不是一件应该特别拨出时间做的事情，重构应该随时随地进行，不应该为重构而重构。

####三次法则

第一次做某件事只管去做；第二次做类似的事会产生反感，但无论如何还是可以去做；第三次再做类似的事，就应该重构。

**事不过三，三则重构**

####添加功能时重构

最常见的重构时间就是我们想给软件添加新特性的时候。直接原因是为了帮助我们理解需要修改的代码。另一个原因是代码的设计无法帮助我轻松添加我所需要的特性。

**重构是一个快速流畅的过程，一旦完成重构，新特性的添加就会更快速，更流畅。**

####修改错误时重构

调试过程中运用重构，多半是为了让代码更具可读性。

####复审代码时重构

代码复审有助于在开发团队中传播知识，也让更多人有机会提出有用的建议。

重构可以帮助自己复审别人的代码。重构还可以帮助代码复审工作得到更具体的结果。

“结对编程”的形式，把代码复审的积极性发挥到了极致。在开发过程中形成随时进行的代码复审工作，而重构也就包含在开发过程内了。

####间接层和重构

重构往往把大型对象拆成多个小型对象，把大型函数拆成多个小型函数。但是，间接层是一柄双刃剑。间接层有它的价值：
* 允许逻辑共享。比如父类中的某个函数被所有子类共享。
* 分开解释意图和实现。选择每个类和函数的名字，给了我们一个解释自己意图的机会，类或函数内部则解释实现这个意图的做法。以更小单元的意图来编写，可以描述其结构中的大部分重要信息。
* 隔离变换。在两个不同地点使用同一对象，其中一个地点想改变对象行为，如果修改就要冒同事影响两处的风险。为此可以做出一个子类，并在需要修改处引用这个子类。
* 封装条件逻辑。多态消息，可以灵活而清晰地表达条件逻辑，将条件逻辑转化为消息形式，能降低代码的重复，增加清晰度并提高弹性、

重构游戏：在保持系统现有行为的前提下，如果才能提高系统的质量或降低其成本，从而使它更有价值。

还有一种比较少见的重构游戏：找出不值得的间接层，并将它拿掉。

###重构的难题

虽然我们坚决认为应该尝试一下重构，获得它所提供的利益，但与此同时，我们也应该时时监控其过程，注意寻找重构可能引入的问题。

####数据库

重构经常出问题的一个领域就是数据库，绝大多数程序都与背后的数据库结构紧密耦合在一起。另一个原因是数据迁移。

对非对象数据库，解决办法之一就是：**在对象模型和数据库模型之间插入一个分隔层，隔离两个模型各自的变化。**

####修改接口

分开修改软件模块的实现和接口，安全地修改对象内部实现而不影响他人，但对于接口要谨慎。

面对已发布接口（published interface），无法仅仅修改调用者而能够安全地修改接口。需要一个更复杂的流程。

如果重构手法改变了已发布接口，必须同时维护新旧两个接口，直到所有用户都有时间对这个变化做出反应。让旧接口调用新接口，千万不要复制函数实现。还应该使用deprecation设施，将旧接口标记为deprecated。

另一个选择就是**不要发布接口，**当然不是完全禁止。

**不要过早发布接口，修改代码所有权政策，使重构更顺畅。**

####难以通过重构手法完成的设计改动

的确也有难以重构的地方，比如说在一个项目中，我们很难将不考虑安全性需求时构造起来的系统重构为具有良好安全性的系统。

遇到这种情况，先想象重构的情况，考虑候选设计方案，选最简单的设计，哪怕不能覆盖所有潜在需求。

####何时不该重构

有时候根本不应该重构，比如既有代码实在太混了，重构还不如重新写来的简单。

重写而非重构的一个清楚讯号就是：**现有代码根本不能正常运作，只是试着做点测试，就发现代码中满是错误，根本步伐稳定运作。**

**重构之前，代码必须起码能够在大部分情况下正常运作。**

折中的办法就是：将“大块头软件”重构为封装良好的小型组件。然后可以逐一对组件做出“重构或重建”的决定。

另外，如果项目已近最后期限，我们也应该避免重构，因为已经没有时间了。

重构的确能够提高生产力，如果最后没有足够时间，通常就表示其实早该进行重构。

###重构与设计

**重构和设计彼此互补！**

做预先设计，但不必一定找出正确的解决方案，只需要得到一个足够合理的解决方案就够了。之后察觉最佳解决方案和当初设想的有些不同就使用重构。

重构可以带来更简单的设计，同时又不损失灵活性，这降低了设计过程的难度，减轻了设计压力。

**劳而无获--哪怕完全了解系统，也请实际度量它的性能，不要臆测，臆测会让你学到一些东西，但十有八九是错的。**

###重构与性能

重构可能使软件运行更慢，但它也使软件的性能优化更容易。首先写出可调的软件，然后调整它以求获取足够速度。

* 时间预算法。分解设计时做好预算，给每个组件预先分配一定资源，包括时间和执行轨迹。每个组件绝对不能超出自己的预算。
* 持续关注法。要求任何程序员在任何时间做任何事时，都要设法保持系统的高性能。
* 系能提升法。编写构造良好的程序，不对性能投以特别的关注，直至进入性能优化阶段，再按照某个特定程序来调整程序性能。

在性能优化阶段，首先用一个度量工具来监控程序，找出哪些地方大量消耗时间和空间，然后集中关注这些性能热点，并使用持续关注法来优化它们。

一个构造良好的程序可从两方面帮助这一优化形式
1. 有比较充裕的时间进行性能调整。有更多时间用在性能问题上。
2. 进行性能分析时有较细的粒度，于是度量工具把你带入范围较小的程序段落中，而性能的调整也比较容易些。

重构可以帮助我们写出更快的软件。短期看来，重构的确可能使软件变慢，但它使优化阶段的软件性能调整更容易，最终还是会得到好的效果。

##代码的坏味道

###Duplicated Dode（重复代码）

坏味道行列中首当其冲的就是Duplicated Code，设法将它们合而为一，程序会变得更好。

* 同一个类的两个函数含有相同的表达式。提炼出重复的代码，然后让这两个地点都调用被提炼出来的那一段代码。
* 两个互为兄弟的子类内含相同表达式。提炼出重复代码，将它推入超类内。若代码只是类似，并非完全相同，将相似部分和差异部分割开，构成单独一个函数。若有些函数以不同的算法做相同的事，选择其中较清晰的一个，并将其他函数的算法替换掉。
* 两个毫不相关的类，将重复代码提炼到一个独立类中，然后在另一个类内使用这个新类。但必须决定这个函数放在哪儿最合适，并确保它被安置后就不会再在其他任何地方出现。

###Long Method（过长函数）

应该更积极地分解函数。每当感觉需要以注释来说明点什么的时候，我们就需要把说明的东西放进一个独立函数中，并以其用途（而非实现手法）命名。

如果函数内有大量的参数和临时变量，它们会对你的函数提炼形成阻碍。我们需要消除这些临时元素。

寻找注释。它们通常能指出代码用途和实现手法之间的语义距离。若代码前方有一行注释，就可以将这段代码替换成一个函数，并且可以在注释的基础上给这个函数命名。

条件表达式和循环常常也是提炼的信号。使用Decompose Conditional处理条件表达式。至于循环，应该将循环和其内的代码提炼到一个独立函数中。

###Large Class（过大的类）

将几个变量一起提炼至新类内。提炼时应该选择类内彼此相关的变量，将它们放在一起。

类内如果有太多代码，也是代码重复，混乱并最终走向死亡的源头。把多余的东西消弭于类内部。

一个类如果拥有太多代码，也适合使用扩展类和扩展接口。先确定客户端如何使用它们，然后为每一种使用方式提炼出一个接口。

###Long Parameter List（过长参数列）

如果你手上没有所需的东西，总可以叫另一个对象给你！因此，有了对象就不必把函数需要的所以东西都以参数传递给它了，只需传给它足够的，让函数能从中获得自己需要的东西就行了。

太长的参数列难以理解，太多参数会造成前后不一致，不易使用，而且一旦需要更多数据，就不得不修改它。若将对象传递给函数，大多数修改都将没有必要，因为很可能只需在函数内增加一两条请求，就能得到更多数据。

有时候明显不希望造成“被调用对象”与“较大对象”间的某种依赖关系。这时候将数据从对象中拆解出来单独作为参数，也很合情合理。

###Divergent Change（发散式变化）

一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改，如果不能做到这点，就需要重构了。

若某个类经常因为不同的原因在不同的方向上发生变化，Divergent Change就出现了。针对某一外界变化的所有相应修改，都只应该发生在单一类中，而这个新类内所有内容都应该反应此变化。

###Shotgun Surgery（霰弹式修改）

若遇到某种变化，都必须在许多不同的类内做出许多小修改，如果需要修改的代码散步四处，不但很难找到它们，也很容易忘记某个重要的修改。

把所有需要修改的代码放进同一个类，若眼下没有合适的类可以安置这些代码，就创造一个。通常可以把一系列相关行为放进同一个类。

Divergent Change是指“一个类受多种变化的影响”，Shotgun Surgery则是指“一种变换引发多个类相应修改”。

###Feature Envy（依恋情结）

函数对某个类的兴趣高过对自己所处类的兴趣。这种情况最通常的焦点便是数据。某个函数为了计算某个值，从另一个对象那儿调用了很多的取值函数。把这个函数移至另一个地点。

判断哪个类拥有最多被此函数使用的数据，然后就把这个函数和那些数据摆在一起。先把这个函数分解为数个较小函数并分别放置于不同地点。

最根本的原则：**将总是一起变化的东西放置一块儿。数据和引用这些数据的行为总是一起变化的。如果例外出现，就搬移这些行为，保持变化只在一地发生。**

###Data Clumps（数据泥团）

两个类中相同的字段，许多函数签名中相同的参数，这些总是绑在一起出现的数据应该拥有属于它们自己的对象。

找出这些数据以字段形式出现的地方，将它们提炼到一个独立对象中。这么做的直接好处是可以将很多参数列缩短，简化函数调用。

**删掉众多数据中的一项，这么做，其他数据有没有因而失去意义？如果它们不再有意义，应该为它们产生一个新对象。**

###Primitive Obsession（基本类型偏执）

对象的一个极大的价值在于：**它们模糊（甚至打破）了横亘于基本数据和体积较大的类之间的界限。**

将原本单独存在的数据值替换为对象，从而走出传统的洞窟，进入炙手可热的对象世界。在小任务上运用小对象！

###Switch Statements（switch惊悚现身）

**少用switch（或case）语句。从本质上说，switch语句的问题在于重复，常会发现同样的switch语句散布于不同地点，要为它添加一个新的case子句，就必须找到所有switch语句并修改它们。**

当看到switch语句，应该考虑以多态来替换它。

###Parallel Inheritance Hierarchies（平行继承体系）

每当为某个类增加一个子类，必须为另一个类相应增加一个子类。消除这种重复性的策略：让一个继承体系的实例引用另一个继承体系的实例。再运用Move Method和Move Field，就可以将引用端的继承体系消弭于无形。

###Lazy Class（冗赘类）

创建的每一个类，都得有人去理解它，维护它。如果一个类的所得不值其身价，就应该消失。

###Speculative Generality（夸夸其谈未来性）

如果你的某个抽象类其实没有太大作用，就消除它。如果所有设想都会被用到，就值得，如果用不到，就不值得。

###Temporary Field（令人迷惑的暂时字段）

其内某个实例变量仅为某种特定情况而设，这样的代码让人不易理解，因为通常认为对象在所有时候都需要它的所有变量。

为这个变量创建一个新类，并且把所有和这个变量相关的代码都放进这个新类。

###Message Chains（过度耦合的消息链）

使用消息链，意味着客户代码将于查找过程中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。

先观察消息链最终得到的对象是用来干什么的，把使用该对象的代码提炼到一个独立函数中，然后把这个函数推入消息链。

###Middle Man（中间人）

多度运用委托。某个类接口有一半的函数都委托给其他类，这样就是过度运用。这时应该去掉“中间人”，直接和真正负责的对象打交道。

###Inappropriate Intimacy（狎昵关系）

两个类过于亲密。过分狎昵的类必须拆散，帮它们划清界线，从而减少狎昵行径。如果两个类实在是情投意合，可以创建一个新类，把两者共同点提炼到一个安全地点，让它们使用这个新类。

继承往往造成过度亲密，因为子类对超类的了解总是超过后者的主观愿望。

###Alternative Classes with Different Interfaces（异曲同工的类）

如果两个函数做同一件事，却有着不同的签名，根据它们的用途重新命名。将某些行为移入类，直到两者的协议一致为止。

###Incomplete Library Class

复用常被视为对象的终极目的。类库构筑着没有未卜先知的能力，类库往往构造得不够好，而且往往不可能让我们修改其中的类使它完成我们希望完成的工作。

###Data Class（纯稚的数据类）

它们拥有一些字段，以及用于访问这些字段的函数。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细琐地操控着。应该将字段封装起来。

###Refused Bequest（被拒绝的遗赠）

子类应该继承超类的函数和数据，但是如果它们不想或不需要继承，又该咋办呢？按传统说法，这意味着继承体系设计错误。需要为这个子类新建一个兄弟类，把所有用不到的函数下推给那个兄弟，这样一来，超类就只持有所有子类共享的东西。但是，不建议这么做，起码不建议每次都这么做。

若子类复用了超类的行为，却又不愿意支持超类的接口，就不合适了。不愿意继承接口，也不要胡乱修改继承体系，把它从继承体系中移除。

###Comments（过多的注释）

看到一段代码有着很长的注释，然后发现这些注释之所以存在乃是因为代码很糟糕。

若需要注释来解释一段代码做了什么，不妨写一个新方法。若函数已经提炼出来，还需要注释，就给函数重命名。

**当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余。**

##构筑测试体系

进行重构，首要前提就是拥有一个可靠的测试环境。

###自测代码的价值

**确保所有测试都完全自动化，让它们检查自己的测试结果。**

编写测试代码其实就是在问自己：添加这个功能需要做些什么。编写测试代码也能使你把注意力集中于接口而非实现。

频繁进行测试时极限编程的重要一环。如果你想重构，就必须编写测试代码。

Java中的测试惯用手法是testing main，每个类都应该有一个用于测试的main()。这是一个合理的习惯，但可能不好操控。

###JUnit测试框架

任何包含测试代码的类都必须继承测试框架所提供的TestCase类。

TestCase类提供两个函数专门准备测试数据
* setUp():用来产生相关对象
* tearDown():负责删除相关对象

**频繁地运行测试，每次编译请把测试也考虑进去--每天至少执行每个测试一次。**

除了捕捉失败，还可以捕捉错误。使用assertEquals()，assert()等;

####单元测试和功能测试

单元测试时高度局部化的东西，每个测试类都隶属于单一包。它能够测试其他包的接口，除此之外它将假设其他包一切正常。

功能测试用来保证软件能够正常运行。从客户的角度保障质量，并不关心程序员的生产力。

**每当收到bug报告，先写一个单元测试来暴露bug。**

###添加更多测试

**观察类该做的所有事情，然后针对任何一项功能的任何一种可能失败情况，进行测试。**

**测试你最担心出错的部分！**

考虑可能出错的边界条件，把测试火力集中在那儿。“寻找边界条件”也包括寻找特殊的，可能导致测试失败的情况。

**不要因为测试无法捕捉所有bug就不写测试，因为测试的确可以捕捉到大多数bug。**

##重构列表

###重构的记录格式
* 名称。建造一个重构词汇表，名称很重要。
* 简短概要。简单介绍此一重构手法的使用情景，以及它所做的事情
* 动机。“为什么需要这个重构”和“什么情况下不适用这个重构”
* 做法。简明介绍如果进行重构
* 范例。简单的例子说明

###寻找引用点

所有重构都要求我们找到对应某个函数，某个字段或某个类的所有引用点。

##重新组织函数

函数分解完毕后，就可以知道如何让它工作得更好，可能还会发现算法可以改进，从而使代码更清晰。

###Extract Method（提炼函数）

**将一段代码放进一个独立函数中，并让函数名称解释该函数的用途。**

####动机

看见一个过长的函数或者一段需要注释才能让人理解用途的代码，就将这段代码放进一个独立函数中。

* 每个函数的粒度都很小，那么函数被复用的机会就更大
* 这会使高层函数读起来就像一系列注释
* 如果函数都是细粒度，那么函数的覆写也会更容易

一个函数多长才算合适？长度不是问题，关键在于函数名称和函数本地之间的语义距离。

####做法

* 创造一个新函数，根据函数的意图来对它命名。（以“做什么”来命名，而不是以它“怎么做”命名）
* 将提炼出的代码从源函数复制到新建的目标函数中
* 仔细检查提炼出的代码，看看其中是否引用了“作用域限于源函数”的变量
* 检查是否有“仅用于被提炼代码段”的临时变量。若有，在目标函数中将它们声明为临时变量。
* 检查被提炼代码段，看看是否有任何局部变量的值被它改变。若一个临时变量值被修改，看看是否可以将提炼代码段处理为一个查询，并将结果赋值给相关变量。
* 将被提炼代码段中需要读取的局部变量，当做参数传给目标函数
* 处理完所有局部变量之后，进行编译。
* 在源函数中，将被提炼代码段替换为目标函数的调用。
* 编译，测试

####范例

* 无局部变量。直接提炼方法
* 有局部变量但是提炼出的代码只是读取这些变量的值，并不修改。将它们当做参数传给目标函数。
* 有局部变量并且提炼出的代码段会对它赋值。
    * 变量只在被提炼代码段中使用。将这个临时变量的声明移到被提炼代码段中。
    * 被提炼代码段之外的代码也使用这个变量。让目标函数返回该变量改变后的值。

###Inline Method(内联函数)

在函数调用点插入函数本地，然后移除该函数

####动机

手上有一群组织不甚合理的函数，将它们都内联到一个大型函数中，再从中提炼出组织合理的小型函数。

若使用了太多间接层，使得系统中的所有函数都似乎只是对另一个函数的简单委托，造成在这些委托动作之间晕头转向，通常都会使用Inline Method。

####做法

* 检查函数，确定它不具多态性（**若子类继承了这个函数，就不要将此函数内联。**）
* 找出这个函数的所有被调用点
* 将这个函数的所有被调用点都替换为函数本体
* 编译，测试
* 删除该函数的定义

**如果遇到了复杂情况，就不应该使用这个重构手法**

###Inline Temp（内联临时变量）

将所有对该变量的引用动作，替换为对它赋值的那个表达式自身。

####动机

唯一单独使用它的情况是：发现某个临时变量被赋予某个函数调用的返回值。一般这样的临时变量不会有任何危害，可以放心地把它留在那儿。但若这个临时变量妨碍了其他的重构手法，就应该将它内联化

####做法

* 检查给临时变量赋值的语句，确保等号右边的表达式没有副作用
* 如果这个临时变量并未被声明为final，那就将它声明为final，然后编译
* 找到该临时变量的所有引用点，将他们替换为表达式
* 每次修改后，编译并测试
* 修改完所有引用点之后，删除该临时变量的声明和赋值语句
* 编译，测试

###Replace Temp with Query（以查询取代临时变量）

临时变量保存某一表达式的运算结果，将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用。此后，新函数就可被其他函数使用。

####动机

临时变量的问题在于：**它们是暂时的，而且只能在所属函数内使用**。如果把临时变量替换为一个查询，那么同一个类中的所有函数都将可以获得这份信息。

局部变量会是代码难以被提炼，所有应该尽可能把它们替换为查询式。

####做法

1. 简单情况

    * 找出被赋值一次的临时变量（若某个临时变量被赋值超过一次，考虑将它分割成多个变量）
    * 将该临时变量声明为final
    * 编译（确保该临时变量的确只被赋值一次）
    * 将对临时变量赋值的语句的等号右侧部分提炼到一个独立函数中。
    * 现将函数声明为private，日后根据情况放松对它的保护。确保提炼出来的函数无任何副作用（该函数并不修改任何对象内容）
    * 编译，测试
    * 在该临时变量身上实现Inline Temp

常常使用临时变量保存循环中的累加信息，这时，整个循环都可以被提炼为一个独立函数。有时，会在一个循环中累加好几个值，这时应该针对每个累加值重复一遍循环，将所有临时变量都替换为查询。

担心性能为题，不可不管它，若性能真的出了问题，也可以在优化时期解决它。

代码组织良好，往往能够发现更有效的优化方案：若没有进行重构，好的优化方案就可能与你失之交臂。

###Introduce Explaining Variable（引入解释性变量）

将复杂表达式（或其中一部分）的结果放进一个临时变量，一次变量名称来解释表达式用途

####动机

表达式有可能非常复杂而难以阅读，临时变量可以帮助我们将表达式分解为比较容易管理的形式

* 条件逻辑，将每个条件子句提炼出来，以一个良好命名的临时变量来解释对应条件子句的意义
* 在较长算法中，可以运用临时变量来解释每一步运算的意义

####做法

* 声明一个final临时变量，将待分解之复杂表达式中的一部分动作的运算结果赋值给它
* 将表达式中的“运算结果”这一部分，替换为上述临时变量
* 编译，测试
* 重复上述过程，处理表达式的其他部分

使用拓展函数来替换临时变量。

###Split Temporary Variable（分解临时变量）

某个临时变量被赋值超过一次，它既不是循环变量，也不被用于收集计算结果。**针对每次赋值，创造一个独立，对应的临时变量**

####动机

循环变量会随循环的每次运行而改变；收集变量负责将整个函数的运算结果收集起来

除上述两种情况，若临时变量承担多个责任，就应该被替换（分解）为多个临时变量，每个变量只承担一个责任

####做法

* 在待分解临时变量的声明及其第一次被赋值处，修改其名称
* 将新的临时变量声明为final
* 以该临时变量的第二次赋值动作为界，修改此前对该临时变量的所有引用点，让它们引用新的临时变量
* 在第二次赋值处，重新声明原先那个临时变量
* 编译，测试
* 逐次重复上述过程。每次都在声明处对临时变量改名，并修改下次赋值之前的引用点

###Remove Assignments to Parameters（移除对参数的赋值）

代码对一个参数进行赋值，以一个临时变量取代该参数的位置

####动机

对于按值传递的情况，对参数的任何修改，都不会对调用端造成任何影响，按引用传递就会对引用对象造成影响

另外，参数表示被传递进来的，不要对参数赋值

####做法

* 建立一个临时变量，把待处理的参数值赋予它
* 以“对参数赋值”为界，将其后所有对此参数的引用点，全部替换为“对此临时变量的引用”
* 修改赋值语句，使其改为对新建之临时变量赋值
* 编译，测试

###Replace Method with Method Object（以函数对象取代函数）

大型函数，其中对局部变量的使用无法采用Extract method。将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段。然后可以在同一个对象中将这个大型函数分解为多个小型函数

####动机

局部变量的存在会增加函数分解的难度，若一个函数中局部变量泛滥成灾，那么分解这个函数式非常困难的。有时候会发现无法拆解一个需要拆解的函数，使用函数对象

将所有局部变量都变成函数对象的字段，然后就可以对这个对象使用Extract Method创造出新函数，从而将原本的大型函数拆解变短

####做法

* 建立一个新类，根据待处理函数的用途，为这个类命名
* 在新类中建立一个final字段，用以保存原先大型函数所在的对象。针对原函数的每个临时变量和每个参数，在新类中建立一个对应的字段保存
* 新类的构造函数，接收源对象及原函数的所有参数作为参数
* 在新类中建立一个函数方法
* 将原函数的代码复制到新类的方法中
* 编译
* 将旧函数的函数本体替换为“创建新类后调用其中的函数”

###Substitute Algorithm（替换算法）

想要把某个算法替换为另一个更清晰的算法。将函数本体替换为另一个算法

####动机

做一件事可以有更清晰的方式，就应该以较清晰的方式取代复杂的方式。重构可以把一些复杂东西分解为较简单的小块，但有时必须壮士断腕，删掉整个算法，代之以较简单的算法

先确定自己已经尽可能分解了原先函数，替换一个巨大而复杂的算法是非常困难的，只有先将它分解为较简单的小型函数，然后才能有把握进行算法替换工作

####做法

* 准备好另一个替换用算法，让它通过编译
* 针对现有测试，执行上述的新算法，若结果与原本结果相同，重构结束
* 若测试结果不同，在测试和调试过程中，以旧算法为比较参照标准
* 对每个测试用例，分别以新旧两种算法执行，并观察两者结果是否相同

##在对象之间搬移特性

在对象设计过程中，“决定把责任放在哪儿”即使不是最重要的事，也是最重要的事之一。

###Move Method（搬移函数）

有个函数与其所驻类之外的另一个类进行更多交流，调用后者或被后者调用。在该函数最常引用的类中建立一个有着类似行为的新函数，将旧函数变成一个单纯的委托函数，或将旧函数完全移除。

####动机

如果一个类有太多行为，或一个类与另一个类有太多合作而形成的高度耦合，就要搬移函数。可以使类更简单，能更干净利落地实现任务

####做法

* 检查源类中被源函数所使用的一切特性，考虑它们是否也该被搬移。（搬移一组函数比逐一搬移简单些）
* 检查源类的子类和超类，看看是否有该函数的其他声明。若出现其他声明，或许就无法进行搬移
* 在目标类中声明这个函数。可以为此函数选择一个新名称--对目标类更有意义的名称
* 将源函数的代码复制到目标函数中，调整后者，使其能正常运行。
* 编译目标类
* 决定如何从源函数正确引用目标对象
* 修改源函数，决定是否删除源函数，或将它当做一个委托函数保留下来
* 编译，测试

###Move Field（搬移字段）

某个字段被其所驻类之外的另一个类更多地用到。在目标类新建一个字段，修改源字段的所有用户，领它们改用新字段

####动机

对于一个字段，在其所驻类之外的另一个类中有更多函数使用了它，就考虑搬移这个字段。也可以移动该字段的用户（某个函数），这取决于是否需要保持接口不受变化。

####做法

* 若字段是public，先将它封装起来
* 编译，测试
* 在目标类中建立与源字段相同的字段，并同时建立相应的设值/取值函数
* 决定如何在源对象中引用目标对象。
* 删除源字段
* 将所有对源字段的引用替换为对某个目标函数的调用
* 编译，测试

###Extract Class（提炼类）

某个类做了应该由两个类做的事，建立一个新类，将相关的字段和函数从旧类搬移到新类

####动机

一个类应该是一个清楚的抽象，处理一些明确的责任。类不断成长扩展，随着责任不断增加，类变的过分复杂

这样的类往往有大量函数和数据，这样的类往往太大而不易理解。需要考虑哪些部分可以分离出去，分离到一个单独的类中。

####做法

* 决定如何分解类所负的责任
* 建立一个新类，用以表现从旧类中分离出来的责任
* 建立“从旧类访问新类”的连接关系
* 搬移函数和字段，先搬移较低层函数，再搬移较高层函数
* 每次搬移之后，编译，测试
* 检查，精简每个类的接口
* 决定是否公开新类，如果的确需要公开它，就要决定让它成为引用对象还是不可变的值对象

Extract Class是改善并发程序的一种常用技术，因为它使你可以为提炼后的两个类分别加锁，若不需要同时锁定两个对象，就不必这样做

###Inline Class（类内联化）

若某个类没有做太多事情，将这个类的所有特性搬移到另一个类中，然后移除原类

####动机

若一个类不再承担足够责任，不再有单独存在的理由，就可以挑选这一“萎缩类”的最频繁用户，将这个类塞进另一个类中

####做法

* 在目标类身上声明源类的public协议，并将其中所有函数委托至源类
* 修改所有源类引用点，改而引用目标类
* 编译，测试
* 把源类的特性全部搬移到目标类
* 为源类举行一个简单的“丧礼”

###Hide Delegate（隐藏“委托关系”）

通过一个委托类来调用另一个对象，在服务类上建立客户所需的所有函数，用以隐藏委托关系

####动机

封装意味每个对象都应该尽可能少了解系统的其他部分。如此一来，一旦发生变化，需要了解这一变化的对象就会比较少--这会使变化比较容易进行

####做法

* 对于每一个委托关系中的函数，在服务对象端建立一个简单的委托函数
* 调整客户，令它只调用服务对象提供的函数
* 每次调整后，编译并测试
* 若将来不再有任何关系需要受委托类，便可移除服务对象中的相关访问函数
* 编译，测试

###Remove Middle Man（移除中间人）

某个类做了过多的简单委托动作，让客户直接调用受托类

####动机

使用Hide Delegate的代价：每当客户要使用受托类的新特性时，就必须在服务端添加一个简单委托函数。随着受托类的特性越来越多，就会很痛苦，服务类完全变成了一个“中间人”，这时就应该让客户直接调用受托类

很难找到什么程度的隐藏才是合适的，这是在系统运行过程中不断进行调整，随着系统的变化，“合适的隐藏程度”这个尺度也相应改变

####做法

* 建立一个函数，用以获得受托对象
* 对于每个委托函数，在服务类中删除该函数，并让需要调用该函数的客户转为调用受托对象
* 处理每个委托函数后，编译，测试

###Introduce Foreign Method（引入外加函数）

需要为提供服务的类增加一个函数，但无法修改这个类。在客户类中建立一个函数，并以第一参数形式传入一个服务类实例

####动机

正在使用一个类，它提供了需要的所有服务。而后，又需要一项新服务，这个类却无法供应，若可以修改源码，便可自行添加一个新函数，若不能，就得在客户端编码，补足需要的那个函数。

若以外加函数实现一项功能，那表明：这个函数原本应该在提供服务的类中实现

若发现为一个服务类建立了大量的外加函数，或发现有许多类都需要同样的外加函数，就不应该再使用本想重构

**外加函数终归是权宜之计，若有可能，仍然应该将这些函数搬移到它们的理想家园**

####做法

* 在客户类中建立一个函数，用来提供你需要的功能
* 以服务类实例作为该函数的第一个参数
* 将该函数注释为“外加函数，应在服务类实现”。将来有机会将外加函数搬移到服务类中时，便可以轻松找出这些外加函数

###Introduce Local Extension（引入本地扩展）

需要为服务类提供一些额外函数，但无法修改这个类。建立一个新类，使它包含这些额外函数，让这个扩展品成为源类的子类或包装类

####动机

若可以修改源码，最好的办法就是直接加入自己需要的函数。但无法修改源码，同时需要的额外函数超过两个，外加函数就很难控制它们了，所以需要将这些函数组织在一起，放到一个恰当地方。

本地扩展是一个独立的类，但也是被扩展类的子类型，它提供源类的一切特性，同时额外添加新特性。在任何使用源类的地方，都可以使用本地扩展取而代之

制作子类的最大障碍在于，它必须在对象创建期实施，若可以接管对象创建过程，当然没问题，但若想在对象创建之后再使用本地扩展，就有问题了。子类化方案还必须产生一个子类对象，这时，若有其他对象引用了旧对象，我们就同时有两个对象保存了原数据

使用包装类时，对本地扩展的修改会波及原对象，反之亦然

####做法

* 创建一个扩展类，将它作为原始类的子类或包装类
* 在扩展类中加入转型构造函数。就是“接受原对象作为参数”的构造函数。若采用子类化方案，那么转型构造函数应该调用适当的超类构造函数，若采用包装类方案，那么转型构造函数应该将它得到的传入参数以实例变量的形式保存起来
* 在扩展类中加入新特性
* 根据需要，将原对象替换为扩展对象
* 将针对原始类定义的所有外加函数搬移到扩展类中

##重新组织数据

###Self Encapsulate Field（自封装字段）

直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙，为这个字段建立取值/设值函数，并且只以这些函数来访问字段

####动机

简介访问变量的好处是：子类可以通过覆写一个函数而改变获取数据的途径，它还支持更灵活的数据管理方式

直接访问变量的好处则是：代码比较容易阅读

先使用直接访问方式，直到这种方式给我们带来麻烦为止

####做法

* 为待封装字段建立取值/设值函数
* 找出该字段的所有引用点，将它们全部改为调用取值/设值函数
* 将该字段声明为private
* 复查，确保找出所有引用点
* 编译，测试

必须小心对待“在构造函数中使用设值函数”的情况。一般设值函数被认为应该在对象创建后才使用，所以初始化过程中的行为有可能与设值函数的行为不同。这时，在构造函数中直接访问字段或者单独另建一个初始化函数

###Replace Data Value with Object（以对象取代数据值）

有一个数据项，需要与其他数据和行为一起使用才有意义。将数据项变为对象

####动机

初期决定以简单的数据项表示简单的情况，随着开发的进行，可能会发现这些简单数据项不再那么简单。若这样的数据项只有一两个，还可以把相关函数放进数据项所属的对象里，但是过多的时候就应该将数据值变为对象

####做法

* 为待替换数值新建一个类，在其中声明一个final字段，其类型和源类中的待替换数值类型一样。然后在新类中加入这个字段的取值函数，再加上一个接受此字段为参数的构造函数
* 编译
* 将源类中的待替换数值字段的类型改为前面新建的类
* 修改源类中该字段的取值函数，令它调用新类的取值函数
* 若源类构造函数中用到这个待替换字段，我们就修改构造函数，令它改用新类的构造函数来对字段进行赋值动作
* 修改源类中待替换字段的设值函数，令它为新类创建一个实例
* 编译，测试

###Change Value to Reference（将值对象改为引用对象）

从一个类衍生出许多彼此相等的实例，希望将它们替换为同一个对象，将这个值对象变为引用对象

####动机

有时会从一个简单的值对象开始，在其中保存少量不可修改的数据。而后，希望给这个对象加入一些可修改数据，并确保对任何一个对象的修改都能影响到所有引用此对象的地方，就需要将这个对象变为一个引用对象

####做法

* 使用Replace Constructor with Factory Method
* 编译，测试
* 决定由什么对象负责提供访问新对象的途径。可能是一个静态字典或一个注册表对象，也可以使用多个对象作为新对象的访问点
* 决定这些引用对象应该预先创建好，或是应该动态创建
* 修改工厂函数，令它返回引用对象
* 编译，测试

###Change Reference to Value（将引用对象改为值对象）

####动机

若引用对象开始变得难以使用，就应该将它改为值对象。引用对象必须被某种方式控制，总是必须向其控制者请求适当的引用对象，它们可能造成内存区域之间错综复杂的关联。

值对象有一个非常重要的特性：它们是不可变的。无论何时，只要调用同一对象的同一个查询函数，都应该得到同样结果。

####做法

* 检查重构目标是否为不可变对象，或是否可修改为不可变对象（若无法将对象修改为不可变的，就放弃使用本项重构）
* 建立equals()和hashCode()
* 编译，测试
* 考虑是否可以删除工厂函数，并将构造函数声明为public

###Replace Array with Object（以对象取代数组）

有一个数组，其中的元素各自代表不同的东西。以对象替换数组，对应数组中的每个元素，以一字段来表示

####动机

数组是一种常见的数据结构，不过，它们应该只用于“以某种顺序容纳一组相似对象”。一个数组容纳了多种不同对象，会给用户带来麻烦。对象就不同了，可以运用字段名称和函数名称来传达这样的信息

####做法

* 新建一个类表示数组所拥有的信息，并在其中以一个public字段保存原先的数组
* 修改数组的所有拥有，让它们改用新类的实例
* 编译，测试
* 逐一为数组元素添加取值/设值函数，根据元素用途，为这些访问函数命名。
* 所有对数组的直接访问都转而调用访问函数后，将新类中保存该数组的字段声明为privte
* 编译
* 对数组的每一个元素，在新类中创建一个类型相当的字段，修改该元素的访问函数，令它改用上述的新建字段
* 每修改一个元素，编译并测试
* 数组的所有元素都有了相应字段之后，删除该数组

###Duplicate Observed Data（复制“被监视数据”）

有一些领域数据置身于GUI控件中，而领域函数需要访问这些数据。将该数据复制到一个领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据

####动机

一个分层良好的系统，应该将处理用户界面和处理业务逻辑的代码分开。同一项数据有可能既需要内嵌与GUI空间，也需要保存于领域模型里，若遇到的代码是以两层方式开发，业务逻辑被内嵌于用户界面之中，就有必要将行为分离出来。

主要工作就是函数的分解和搬移，但数据不同，不能仅仅只是移动数据，必须将它复制到新的对象中，并提供相应的同步机制

####做法

* 修改展现类，使其成为领域类的Observer
* 针对GUI类中的领域数据，使用Self Encapsulate Field
* 编译，测试
* 在事件处理函数中调用设值函数，直接更新GUI组件
* 编译，测试
* 在领域类中定义数据及其相关访问函数
* 在修改展现类中的访问函数，将它们的操作对象改为领域对象（而非GUI组件）
* 修改Observer的update()，使其从相应的领域对象中将所需数据复制给GUI组件
* 编译，测试

####使用事件监听器

不适用观察者模式也可以，使用事件监听器。每当领域对象发生变化，就向监听器发送一个事件。

###Change Unidirectional Association to Bidirectional（将单向关联改为双向关联）

两个类都需要使用对方特性，但其间只有一条单向链接。添加一个反向指针，并使修改函数能够同时更新两条链接。

####动机

开发初期，两个类之间建立一条单向连接，使其中一个类可以引用另一个类。随着时间推移，两个类需要互相引用，就需要建立双向引用关系，或称为**反向指针**

####做法

* 在被引用类中增加一个字段，用以保存反向指针
* 决定由哪个类--引用端还是被引用端--控制关联关系
* 在被控端建立一个辅助函数，其命名应该清楚指出它的有限用途
* 如果既有的修改函数在控制端，让它负责更新反向指针
* 如果既有的修改函数在被控端，就在控制端建立一个控制函数，并让既有的修改函数调用这个新建的控制函数

###Change Bidirectional Association to Unidirectional（将双向关联改为单向关联）

两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性，去除不必要的关联

####动机 

双向关联很有用，但是也有代价：维护双向连接，确保对象被正确创建和删除而增加的负责度。

大量的双向连接容易造成内存泄漏。

另外，双向关联迫使两个类之间有了依赖：对其中任一个类的任何修改，都可能引发另一个类的变化。

只有在真正需要双向关联的时候，才应该使用它。若发现双向关联不再有存在价值，就应该去掉其中不必要的一条关联。

####做法

* 找出保存“你想去除的指针”的字段，检查它的每一个用户，判断是否可以去除该指针
* 若客户使用了取值函数，先将待删除字段自我封装起来，然后对付取值函数，令它不再使用该字段。然后编译，测试
* 若客户并未使用取值函数，那就直接修改待删除字段的所有被引用点：改以其他途径获得该字段所保存的对象。每次修改后，编译并测试
* 若已经没有任何函数使用待删除字段，移除所有对该字段的更新逻辑，然后移除该字段
* 编译，测试

###Replace Magic Number with Symbolic Constant（以字面常量取代魔法数）

有一个字面数组，带有特别含义。创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量

####动机

魔法数是指拥有特殊意义，却不能明确表现出这种意义的数字。

若在不同的地点引用同一个逻辑数，一旦这些数发生改变，就必须在程序中找到所有魔法数，并将它们全部修改一遍，这简直就是噩梦。就算不修改，准确指出每个魔法数的用途也不易。

常量不会造成任何性能开销，却可以大大提高代码的可读性。

####做法

* 声明一个常量，令其值为原本的魔法数值
* 找出这个魔法数的所有引用点
* 检查是否可以使用这个新声明的常量来替换该魔法数
* 编译
* 所有魔法数都被替换完毕后，编译并测试

###Encapsulate Field

类中存在一个public字段，将它声明为private，并提供相应的访问函数

####动机

面向对象的首要原则之一就是封装。数据声明为public被看做一种不好的做法，因为这样会降低程序的模块化程度

将数据隐藏起来，并提供相应的访问函数。

####做法

* 为public字段提供取值/设值函数
* 找到这个类以外使用该字段的所有地点。若只是读取该字段，就把引用替换为对取值函数的调用。若客户修改了该字段值，就替换为对设值函数的调用
* 每次修改后，编译并测试
* 将字段的所有用户修改完毕后，把字段声明为private
* 编译，测试

###Encapsulate Collection（封装集合）

有个函数返回一个集合，让这个函数返回该集合的一个只读副本，并在这个类中提供添加/移除集合元素的函数

####动机

常会使用集合来保存实例，提供取值/设值函数。

取值函数不应该返回集合自身，这会让用户得以修改集合内容而集合拥有者却一无所知。还会对用户暴露过多对象内部数据结构的信息。

不应该为整个集合提供一个设值函数，应该提供用以为集合添加/移除元素的函数

####做法

* 加入为集合添加/移除元素的函数
* 将保存集合的字段初始化为一个空集合
* 编译
* 找出集合设值函数的所有调用者。修改设值函数，使用新建立的“添加/移除元素”函数，也可以直接修改调用端，直接调用新建立的函数
* 编译，测试
* 找出所有调用取值函数的地方，逐一修改，改用添加/移除函数
* 修改取值函数自身，使它返回该集合的一个只读副本
* 编译，测试

###Replace Record with Data Class（以数据类取代记录）

需要面对传统编程环境中的记录结果，为该记录创建一个“哑”数据对象

####动机

记录型结构是许多编程环境的共同性质。创建一个接口类，用来处理外来数据。先建立一个看起来类似外部记录的类，以便日后将某些字段和函数搬移到这个类中

####做法

* 新建一个类，表示这个记录
* 对于记录中的每一项数据，在新建的类中建立对应的一个private字段，并提供相应的取值/设值函数

###Replace Type Code with Class（以类取代类型码）

类之中有数值类型码，但是并不影响类的行为。以一个新的类替换该数值类型码

####动机

类型码或枚举值很常见，符号名终究只是个别名，编译器看见的，进行类型检验的，还是背后那个数值。

把那样的数值换成一个类，编译器就可以对这个类进行类型检验。只要为这个类提供工厂函数，就可以始终保证是有合法的实例才会被创建出来，且它们都会被传递给正确的宿主对象

####做法

* 为类型码建立一个类。需要一个用以记录类型码的字段，类型和类型码相同，并有对应的取值函数。还应该用一组静态变量保存允许被创建的实例，并以一个静态函数根据原本的类型码返回合适的实例
* 修改源类实现，使用新建的类
* 编译，测试
* 对应源类中每一个使用类型码的函数，相应建立一个函数，让新函数使用新建的类
* 逐一修改源类用户，让它们使用新接口
* 删除使用类型码的旧接口，并删除保存旧类型码的静态变量
* 编译，测试

###Replace Type Code with Subclasses（以子类取代类型码）

有一个不可变的类型码，会影响类的行为，以子类取代这个类型码

####动机

若类型码会影响宿主类的行为，最好的办法就是借助多态来处理变化行为

继承体系以类型码的宿主类为基类，并针对每一种类型码各建立一个子类

####做法

* 把类型码自我封装起来，若类型码被传递给构造函数，就需要将构造函数换成工厂函数
* 为类型码的每一个数值建立一个相应的子类，在每个子类中覆写类型码的取值函数，使其返回相应的类型码
* 每建立一个新的子类，编译并测试
* 从超类中删掉保存类型码的字段，将类型码访问函数声明为抽象函数
* 编译，测试

###Replace Type Code with State/Strategy（以State/Strategy取代类型码）

有一个类型码，会影响类的行为，但无法通过继承手法消除它。以状态对象取代类型码

####动机

类型码的值在对象生命期中发生变化或其他原因使得宿主类不能被继承，使用本重构

####做法

* 将类型码自我封装起来
* 新建一个类，根据类型码的用途为它命名
* 为这个新类添加子类，每个子类对应一种类型码
* 在超类中建立一个抽象的查询函数，用以返回类型码，每个子类覆写该函数，返回确切的类型码
* 编译
* 在源类中建立一个字段用以保存新建的状态对象
* 调整源类中负责查询类型码的函数，将查询动作转发给状态对象
* 调整源类中为类型码设置的函数，将一个恰当的状态对象子类赋值给“保存状态对象”那个字段
* 编译，测试

###Replace Subclass with Field（以字段取代子类）

每个子类唯一差别只在“返回常量数据”的函数身上。修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类

####动机

建立子类的目的，是为了增加新特性或变化其行为。若子类中只有常量函数，实在没有足够的存在价值。

####做法

* 对所有子类使用Replace Constructor with Factory Method
* 若有任何代码直接引用子类，令它改而引用超类
* 针对每个常量函数，在超类中声明一个final字段
* 为超类声明一个protected构造函数，用以初始化这些新增字段
* 新建或修改子类构造函数，使它调用超类的新增构造函数
* 编译，测试
* 在超类中实现所有常量函数，令它们返回相应字段值，然后将该函数从子类中删除
* 子类中所有的常量函数都被删除后，将子类构造函数内联到超类的工厂函数中
* 将子类删除
* 编译，测试

##简化条件表达式

条件逻辑有可能十分复杂，需要简化它们。

###Decompose Conditional（分解条件表达式）

有一个复杂的条件语句，从if,else中分别提炼出独立函数

####动机

复杂的条件逻辑是最常导致复杂度上升的地点之一。大型函数自身就会使代码的可读性下降，而条件逻辑则会使代码更难阅读。

和任何大块头代码一样，可以将它分解为多个独立函数，根据每个小块代码的用途，为分解而得的新函数命名，并将源函数中对应的代码改为调用新建函数

####做法

将每个条件段落中的代码都提炼出来，构成一个独立函数

###Consolidate Conditional Expression（合并条件表达式）

有一系列条件测试，都得到相同结果，将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立函数

####动机

检查条件各不相同，最终行为却一致，应该使用逻辑或和逻辑与将它们合并为一个条件表达式。

合并后的条件代码会告诉我们实际上只有一次条件检查，只是有多个并列条件需要检查，从而使检查的用意更清晰。

若认为这些检查的确彼此独立，的确不应该被视为同一次检查，就不要使用本项重构。

####做法

* 确定这些条件语句都没有副作用
* 使用适当的逻辑操作符，将一系列条件表达式合并为一个
* 编译，测试
* 对合并后的条件表达式实施Extract Method

###Consolidate Duplicate Conditional Fragments（合并重复的条件片段）

在条件表达式的每个分支上有着相同的一段代码，将这段重复代码搬移到条件表达式之外

####动机

一组条件表达式的所有分支都执行了相同的某段代码，就应该将这段代码搬移到条件表达式外面，更清楚地表明哪些东西随条件的变化而变化，哪些东西保持不变

####做法

* 鉴别出“执行方法不随条件变化而变化”的代码
* 若这些共通代码位于条件表达式起始处，就将它移到条件表达式之前
* 若这些共通代码位于条件表达式尾端，就将它移到条件表达式之后
* 若共通代码不止一条，先将它提炼到一个独立函数中

###Remove Control Flag（移除控制标记）

在一系列布尔表达式中，某个变量带有“控制标记”的作用，以break或return语句取代控制标记

####做法

* 找出让你跳出这段逻辑的控制标记值
* 找出对标记变量赋值的语句，代以恰当的break语句或continue语句
* 每次替换后，编译测试

###Replace Nested Conditional with Guard Clauses（以卫语句取代嵌套条件表达式）

函数中的条件逻辑使人难以看清正常的执行路径，使用卫语句表现所有特殊情况

####动机

若两条分支都是正常行为，就应该使用if...else...的条件表达式。若某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。

**这样的单独检查常常成为“卫语句”**

####做法

* 对于每个检查，放进一个卫语句
* 每次将条件检查替换为卫语句后，编译测试

**常常可以将条件表达式反转，从而把复杂的判断改为简单的卫语句**

###Replace Conditional with Polumorphism（以多态取代条件表达式）

有个条件表达式，根据对象类型的不同而选择不同的行为。将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数

####动机

多态最根本的好处就是：若你需要根据对象的不同类型而采取不同的行为，多态使我们不必编写明显的条件表达式

####做法

首先必须有一个继承结构。两种选择：Replace Type Code with Subclasses 和Replace Type Code with State/Strategy。

第一种比较简单，应该尽可能使用它。若需要在对象创建好之后修改类型码，就使用第二种。

* 若要处理的条件表达式是一个更大函数中的一部分，先将它提炼到一个独立函数中
* 若有必要，将条件表达式放置到继承结构的顶端
* 任选一个子类，在其中建立一个函数，使之覆写超类中容纳条件表达式的那个函数。将与该子类相关的条件表达式分支复制到新建函数中，并对它进行适当调整
* 编译，测试
* 在超类中删掉条件表达式内被复制了的分支
* 编译，测试
* 针对条件表达式的每个分支，重复上述过程
* 将超类中容纳条件表达式的函数声明为抽象函数

###Introduce Null Object（引入Null对象）

需要再三检查某对象是否为null时，将null值替换为null对象

####动机

当某个字段内容是null时，多态可扮演另一个较不直观的用途。

空对象一定是常量，它们的任何成分都不会发生变化。可以使用单例模式来实现它们。

####做法

* 为源类建立一个子类，使其行为就像是源类的null版本。在源类和null子类中都加上isNull()函数，前者返回false，后者返回true。建立一个nullable接口，将isNull()放在其中，让源类实现这个接口。
* 编译
* 找出所有判空的地方，修改这些地方，使它们改而获得一个空对象
* 找出所有“将原对象与null作比较”的地方，修改这些方法，调用isNull()函数
* 编译，测试
* 在null类中覆写A动作，在源类中覆写B动作
* 删除“对象是否等于null”的条件测试
* 编译，测试

####特殊情况

使用本项重构时，可以有几种不同的空对象，可以针对不同的情况建立不同的空对象类。

这是一个比Null Object模式更大的模式：Special Case模式。特例类的价值是：它们可以降低我们“错误处理”开销

###Introduce Assertion（引入断言）

某段代码需要对程序状态做出某种假设，以断言明确表现这种假设

####动机

只有当某个条件为真时，该段代码才能正常运行。

**使用断言明确表明这些假设**

断言是一个条件表达式，应该总是为真。断言绝对不能被系统的其他部分使用。标记“某些东西是个断言”很重要

####做法

若程序员不犯错，断言就应该不会对系统运行造成任何影响，所有加入断言永远不会影响程序的行为。

* 若你发现代码假设某个条件始终为真，就加入一个断言说明这种情况。可以新建一个Assert类，用于处理各种情况下的断言。

**不要滥用断言。不要用它来检查“认为应该为真”的条件，只使用它来检查“一定必须为真”的条件。滥用断言可能会造成难以维护的重复逻辑。**

若断言所指示的约束条件不能满足，代码是否仍能正常运行？若可以，就把断言拿掉。

**注意断言中的重复代码。它们和其他任何地方的重复代码一样不好**

##简化函数调用

容易理解和使用的接口，是开发良好面向对象软件的关键。

###Rename Method（函数改名）

函数的名称未能揭示函数的用途，修改函数的名称

####动机

将复杂的处理过程分解成小函数，关键在于给函数起一个好名称。

####做法

* 检查函数签名是否被超类或子类实现过，若是，需要针对每份实现分别进行
* 声明一个新函数，将它命名为你想要的新名称，将旧函数的代码复制到新函数中，并进行适当调整
* 编译
* 修改旧函数，令它将调用转发给新函数
* 编程，测试
* 找出旧函数的所有被引用点，修改它们，令它们改而引用新函数
* 删除旧函数。若旧函数是public接口，将它保留在原处，将它标记为deprecated
* 编译，测试

