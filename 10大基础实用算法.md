# 基础实用算法

## 1.快速排序算法

在平均状况下，排序n个项目要**Ο(nlogn)**次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。

### 算法步骤

1. 从数列中挑出一个元素，称为 “基准”（pivot）。
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。

### 算法实现
![](/assets/quickSort.jpeg)

## 2.堆排序算法

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

**堆排序的平均时间复杂度为Ο(nlogn)。**

### 算法步骤

1. 创建一个堆H[0..n-1]
2. 把堆首（最大值）和堆尾互换
3. 把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置
4. 重复步骤2，直到堆的尺寸为1

### 算法实现
![](/assets/HeapSort.jpeg)

## 3.归并算法

归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

### 算法步骤

1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置
3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
4. 重复步骤3直到某一指针达到序列尾
5. 将另一序列剩下的所有元素直接复制到合并序列尾

### 算法实现
![](/assets/MergeSort.jpeg)

## 4.二分查找算法

二分查找算法是一种在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn) 。

### 算法实现
![](/assets/BinarySearch.jpeg)

## 5.BFPTR（线性查找算法）

BFPRT算法解决的问题十分经典，即从某n个元素的序列中选出第k大（第k小）的元素，通过巧妙的分析，BFPRT可以保证在最坏情况下仍为线性时间复杂度。该算法的思想与快速排序思想相似，当然，为使得算法在最坏情况下，依然能达到o(n)的时间复杂度，五位算法作者做了精妙的处理。

### 算法步骤

1. 将n个元素每5个一组，分成n/5(上界)组。
2. 取出每一组的中位数，任意排序方法，比如插入排序。
3. 递归的调用selection算法查找上一步中所有中位数的中位数，设为x，偶数个中位数的情况下设定为选取中间小的一个。
4. 用x来分割数组，设小于等于x的个数为k，大于x的个数即为n-k。
5. 若i==k，返回x；若`i<k`，在小于x的元素中递归查找第i小的元素；若`i>k`，在大于x的元素中递归查找第i-k小的元素。
终止条件：n=1时，返回的即是i小元素。

### 算法实现
![](/assets/BFPTRSearch_1.jpeg)
![](/assets/BFPTRSearch_2.jpeg)
## 6.DFS（深度优先搜索）

深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。DFS属于盲目搜索。
深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。

### 算法步骤

1. 访问顶点v；
2. 依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；
3. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。
上述描述可能比较抽象，举个实例：
DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1邻 接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，… 如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。
接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。

### 算法实现

略

## 7.BFS（广度优先搜索）

广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。BFS同样属于盲目搜索。一般用队列数据结构来辅助实现BFS算法。

### 算法步骤

1. 首先将根节点放入队列中。
2. 从队列中取出第一个节点，并检验它是否为目标。
如果找到目标，则结束搜寻并回传结果。
否则将它所有尚未检验过的直接子节点加入队列中。
3. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。
4. 重复步骤2。

### 算法实现

略

## 8.Dijkstra算法

戴克斯特拉算法（Dijkstra’s algorithm）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。

该算法的输入包含了一个有权重的有向图 G，以及G中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u, v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示G中所有边的集合，而边的权重则由权重函数 w: E → [0, ∞] 定义。因此，w(u, v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t的最低权重路径(例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。对于不含负权的有向图，Dijkstra算法是目前已知的最快的单源最短路径算法。

### 算法步骤

1. 初始时令 S={V0},T={其余顶点}，T中顶点对应的距离值
若存在`<V0,Vi>`，d(V0,Vi)为`<V0,Vi>`弧上的权值
若不存在`<V0,Vi>`，d(V0,Vi)为∞
2. 从T中选取一个其距离值为最小的顶点W且不在S中，加入S
3. 对其余T中顶点的距离值进行修改：若加进W作中间顶点，从V0到Vi的距离值缩短，则修改此距离值
重复上述步骤2、3，直到S中包含所有顶点，即W=Vi为止

### 算法实现

针对无向图，正权值路径，求最短路径问题，使用该算法实现：

![](/assets/Dijkstra_1.gif)

![](/assets/Dijkstra_main.jpeg)
![](/assets/Dijkstra_alg.jpeg)

## 9.动态规划算法

动态规划（Dynamic programming）是一种在数学、计算机科学和经济学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。 这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

关于动态规划最经典的问题当属背包问题。

### 算法步骤

1. 最优子结构性质。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质（即满足最优化原理）。最优子结构性质为动态规划算法解决问题提供了重要线索。
2. 子问题重叠性质。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率。

### 算法实现（以背包问题为例）

假设现有容量15kg的背包，另外有4个物品，分别为a1，a2，a3, a4。物品a1重量为3kg，价值为4；物品a2重量为4kg，价值为5；物品a3重量为5kg，价值为6, a4重6千克，价值为7。将哪些物品放入背包可使得背包中的总价值最大？

所涉及的数据比较少的时候，我们通过列举就能算出来，例如，上边的例子的答案是：将a4和a3与a2放入背包中，这样总重量为6+5+4=15，总价值为5+6+7=18，这样总价值最大。但是如果上述给出的条件很多，此时我们光靠用眼睛看是绝对不行的，所以我们要用上动态规划的思想。

* w[i] : 第i个物体的重量；
* p[i] : 第i个物体的价值；
* c[i][m] ：前i个物体放入容量为m的背包的最大价值；
* c[i-1][m] ：前i-1个物体放入容量为m的背包的最大价值；
* c[i-1][m-w[i]] ： 前i-1个物体放入容量为m-w[i]的背包的最大价值；

由此可得：
c[i][m]=max{c[i-1][m-w[i]]+pi , c[i-1][m]}（此时用到递归）

![](/assets/Dynamic_item.jpeg)
![](/assets/Dynamic_main.jpeg)
![](/assets/Dynamic_solution.jpeg)
## 10.朴素贝叶斯分类算法

朴素贝叶斯分类算法是一种基于贝叶斯定理的简单概率分类算法。贝叶斯分类的基础是概率推理，就是在各种条件的存在不确定，仅知其出现概率的情况下，如何完成推理和决策任务。概率推理是与确定性推理相对应的。而朴素贝叶斯分类器是基于独立假设的，即假设样本每个特征与其他特征都不相关。
朴素贝叶斯分类器依靠精确的自然概率模型，在有监督学习的样本集中能获取得非常好的分类效果。在许多实际应用中，朴素贝叶斯模型参数估计使用最大似然估计方法，换言之朴素贝叶斯模型能工作并没有用到贝叶斯概率或者任何贝叶斯模型。

尽管是带着这些朴素思想和过于简单化的假设，但朴素贝叶斯分类器在很多复杂的现实情形中仍能够取得相当好的效果。

## 11.冒泡排序

冒泡排序是一种交换排序：**两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。**

使用优化后的冒泡排序，最好的情况下，仅需要n - 1次比较，时间复杂度为O(n)；最坏情况下，需要n(n - 1)/2次比较和交换；所以平均时间复杂度为O(n2)。

### 算法实现
 
    public static void bubbleSort(int[] array) {
        if (array == null || array.length < 1) {
            return;
        }

        int size = array.length;
        for (int i = 0; i < size; i++) {
            for (int j = i + 1; j < size; j++) {
                if (array[j] < array[i]) {
                    int temp = array[j];
                    array[j] = array[i];
                    array[i] = temp;
                }
            }
        }
    }

冒泡排序可以优化，如果经过一轮发现已经是有序的，就不再进行排序：

    public static void bubbleSimpleSort(int[] array) {
        if (array == null || array.length < 1) {
            return;
        }

        int size = array.length;
        boolean swap = true;
        for (int i = 0; i < size && swap; i++) {
            swap = false;
            for (int j = i + 1; j < size; j++) {
                if (array[j] < array[i]) {
                    int temp = array[j];
                    array[j] = array[i];
                    array[i] = temp;
                    swap = true;
                }
            }
        }
    }

## 12.简单选择排序

**每一次遍历时选取关键字最小的记录作为有序序列的第i个记录。**

简单选择排序最大的特点就是交换移动数据次数少，但它的比较次数是和数组本身是否有序是无关的，即无论最好最差的情况，都要进行n(n-1)/2次比较；在最好的情况下，不需要进行交换，在最坏的情况下，进行n-1次交换。所以平均时间复杂度为O(n2)。

### 算法实现

    public static void selectSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        int size = array.length;

        for (int i = 0 ; i < size;i++) {
            int minIndex = i;

            for (int j = i + 1; j < size ;j++) {
                if (array[j] < array[minIndex]) {
                    minIndex = j;
                }
            }

            if (minIndex != i) {
                int temp = array[i];
                array[i] = array[minIndex];
                array[minIndex] = temp;
            }

        }

    }

## 13.直接插入排序

### 算法步骤：

将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录递增1的有序表。 
**插入排序是进行值移动，而不是值交换。**所以在量较小的情况下插入排序性能要优于冒泡和简单选择排序。

在最好的情况下，只需进行比较n - 1次，无需进行移动；在最坏的情况下，比较(n + 2)(n - 1)/2次，交换(n + 4)(n - 1)/2次。所以平均时间复杂度O(n2)

### 算法实现

    public static void straightInserSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        int size = array.length;

        for (int i = 1;i<size;i++) {
            int j = i - 1;
            int temp = array[i];

            while (j >= 0 && array[j] > temp) {
                array[j + 1] = array[j];
                --j;
            }

            array[j + 1] = temp;

        }
    }

## 14.希尔排序

希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。**希尔排序是非稳定排序算法。**

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

希尔排序的算法复杂度和增量序列有关，只要最终步长为1任何步长序列都可以工作。

### 算法实现

    public static void shellSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        int gap = 1;
        int size = array.length;

        while (gap < size / 3) {
            gap = gap * 3 + 1;
        }

        while (gap > 0) {
            for (int i = gap; i < size; ++i) {
                int temp = array[i];
                int j = 0;
                for (j = i - gap; j >= 0 && array[j] > temp; j -= gap) {
                    array[j + gap] = array[j];
                }
                array[j + gap] = temp;
            }
            gap /= 3;
        }
    } 

## 15.桶排序

工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。

### 算法步骤

1. 设置一个定量的数组当作空桶子。
2. 寻访序列，并且把项目一个一个放到对应的桶子去。
3. 对每个不是空的桶子进行排序。
4. 从不是空的桶子里把项目再放回原来的序列中。

对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为： 
O(N)+O(M*(N/M)log(N/M))=O(N+N(logN-logM))=O(N+N*logN-N*logM) 
可以看出，最好情况即当N=M时，每个桶只有一个数据时，能够达到O(N)。

### 算法实现

    /**
     * @param array
     * @param step  每个桶放几个数字
     */
    public static void bucketSort(int[] array, int step) {
        if (array == null || array.length <= 1) {
            return;
        }
        int max = array[0], min = array[0], length = array.length;
        for (int i = 1; i < length; ++i) {
            max = array[i] > max ? array[i] : max;
            min = array[i] < min ? array[i] : min;
        }

        // 计算桶个数
        int num = (int) Math.ceil((max - min + 1) / (step + 0F));
        if (num < 1) num++;

        // 建桶,使用二维数组来存储，Integer可以避免数字为0而无法区分的情况
        List<List<Integer>> list = new LinkedList<List<Integer>>();

        for (int i = 0; i < num; ++i) {
            list.add(new LinkedList<Integer>());
        }

        // 将数据放入对应桶内
        for (int i = 0; i < length; i++) {
            int index = (array[i] - min) / step;
            list.get(index)
                    .add(array[i]);
        }

        // 对每个桶内部排序（可以递归桶排序）
        for (int i = 0; i < num; i++) {
            list.set(i, sort(list.get(i)));
        }

        // 将排序后的桶放回数组
        int k = 0;
        for (int i = 0, size = list.size(); i < size; ++i) {
            List<Integer> temp = list.get(i);

            for (int j = 0; j < temp.size(); j++) {
                array[k] = temp.get(j);
                k++;
            }
        }
    }


    private static List<Integer> sort(List<Integer> list) {
        //使用插入排序
        if (list == null) return null;

        for (int i = 1, j, temp, size = list.size(); i < size; ++i) {

            j = i - 1;
            temp = list.get(i);

            while (j >= 0 && list.get(j) > temp) {
                list.set(j + 1, list.get(j));
                --j;
            }

            list.set(j + 1, temp);
        }

        return list;
    }

## 16.计数排序

计数排序是一种 **稳定的线性时间排序算法。** 
计数排序使用一个额外的数组C，其中C数组的第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。

### 算法步骤

1. 找出待排序的数组中最大和最小的元素
2. 统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项
3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
4. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

当输入的元素是n个0到k之间的整数时，它的运行时间是Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

    public static int[] countSort(int[] array) {
        if (array == null || array.length <=1) {
            return null;
        }

        int b[] = new int[array.length];
        int max = array[0], min = array[0];
        for (int i : array) {
            max = i > max ? i : max;
            min = i < min ? i : min;
        }

        //这里k的大小是要排序的数组中，元素大小的极值差+1
        int k = max - min + 1;
        int c[] = new int[k];

        /*
            array[i]的出现次数放在数组c的第a[i] - min个中
            即：min + i 出现了 c[i]次
         */
        for (int i = 0; i < array.length; ++i) {
            c[array[i] - min] += 1;
        }

        /*
            统计出小于等于a[i]的个数有几个
         */
        for (int i = 1; i < c.length; ++i) {
            c[i] = c[i] + c[i - 1];
        }

        /*
            例如有10个年龄不同的人，统计出有8个人的年龄比A小，那A的年龄就排在第9位，用这个方法可以得到其他每个人的位置，也就排好了序。
         */

        for (int i = array.length - 1; i >= 0; --i) {
            // --c[array[i] - min],小于等于它的有这么多个，就排在这个位置上，数组下标要减1
            // 此处c数组在不断变化，取走一个，小于等于它的便少了一个
            int index = --c[array[i] - min];

            b[index] = array[i];//按存取的方式取出c的元素
        }

        return b;

    }

## 17.基数排序

基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。

### 算法步骤

将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

基数排序的时间复杂度是O(kn)，其中n是排序元素个数，k是数字位数。k决定了进行多少轮处理，而n是每轮处理的操作数目

### 算法实现

    public static void radixSort(int[] array) {
        if (array == null || array.length <= 1) {
            return;
        }

        /*
            1. 计算最大位数
         */
        int maxBit = maxBit(array);
        
        if (maxBit == -1) {
            return;
        }

        /*
            2. 获取每一位，使用计数排序进行排序
         */
        int j, k, radix = 1, length = array.length;
        int[] count = new int[10]; // 0 ~ 9
        int[] temp = new int[length];

        for (int i = 1; i <= maxBit; ++i) {

            for (j = 0; j < 10; ++j) {
                count[j] = 0; //初始化
            }

            //统计位数为i的个数
            for (j = 0; j < length; ++j) {
                k = (array[j] / radix) % 10;
                ++count[k];
            }

            // 位数小于等于i的个数
            for (j = 1; j < 10; ++j) {
                count[j] = count[j] + count[j - 1];
            }

            //开始排序
            for (j = length - 1; j >= 0; j--) {//将所有桶中记录依次收集到tmp中
                k = (array[j] / radix) % 10;
                temp[count[k] - 1] = array[j];
                count[k]--;
            }

            for (j = 0; j < length; ++j) {
                array[j] = temp[j];
            }

            radix *= 10;
        }
    }

    private static int maxBit(int[] arr) {
        if (arr == null) {
            return -1;
        }
        int max = arr[0];
        for (int i = 1, length = arr.length; i < length; ++i) {
            max = arr[i] > max ? arr[i] : max;
        }

        int maxBit = 0;
        while (max >= 1) {
            maxBit++;
            max /= 10;
        }

        return maxBit;
    }

