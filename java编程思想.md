# Java编程思想

### Queue

队列是一个典型的**先进先出**的容器。即从容器的一端放入事物，从另一端取出，并且事物放入容器的顺序与取出的顺序是相同的。

LinkedList提供了方法以支持队列的行为，并且它实现了Queue接口，因此LinkedList可以用作Queue的一种实现。

### PriorityQueue
优先级队列声明下一个弹出元素时最需要的元素（具有最高的优先级）。

PriorityQueue可以确保当你调用peek(),poll()和remove()方法时，获取的元素将是队列中优先级最高的元素。

如果要进行**大量的随机访问**，就使用ArrayList；如果要经常**从表中间插入或删除元素**，就是用LinkedList。

新程序不应该使用过时的Vector，Hashtable和Stack。

## 通过异常处理错误
异常处理是Java中唯一正式的错误报告机制，并且通过编译器强制执行。

使用异常的明显好处是，它往往能够降低错误处理代码的复杂度。

## Java标准异常
Throwable对象可分为两种类型：**Error**用来表示编译时和系统错误；**Exception**是可以被抛出的基本类型。

**RuntimeException**是运行时异常，它们会自动被Java虚拟机抛出，所以不必在异常说明中把它们列出来。这些异常都是从RuntimeException类继承而来。它们也被称为**“不受检查异常”**。

只有在你知道如何处理的情况下才捕获异常。

### 异常使用指南
* 在恰当的级别处理问题
* 解决问题并且重新调用产生异常的方法
* 进行少许修补，然后绕过异常发生的地方继续执行
* 用别的数据进行计算，以代替方法预计会返回的值
* 把当前运行环境下能做的事情尽量做完，然后把**相同**的异常重新抛到最高层
* 把当前运行环境下能做的事情尽量做完，然后把**不同**的异常重新抛到更高层
* 终止程序
* 进行简化
* 让类库和程序更安全

## 字符串
###不可变String
String对象是不可变的。String作为方法参数时，实际传递的是引用的一个拷贝。

##类型信息
1. “传统的”RTTI，假定我们在编译时已经知道了所有的类型。
2. “反射”机制，允许我们在运行时发现和使用类的信息。

Java使用Class对象来执行其RTTI（*在运行时，识别一个对象的类型*）

在传递给forName()的字符串中，必须使用**全限定名（包含包名）**

向**Class**引用添加泛型语法的原因_仅仅是为了提供编译期类型检查_。

对instanceof有比较严格的限制：只可将其与命名类型进行比较，而不能与Class对象作比较。

##泛型
###简单泛型
用尖括号括住，放在类名后面
```
public class Holder<T> {
    private T a;
    public void set(T t) {
        this.a = t;
    }
    public T get() {
        return a;
    }
}
```

使用的时候：
```
Holder<Integer> holder= new Holder<Integer>();

int i = 0;

holder.set(i);

i = holder.get();
```

Java泛型的核心概念：**告诉编译器想使用什么类型，然后编译器帮你处理一切细节。**

**元组**，将一组对象直接打包存储于其中的一个单一对象，这个容器对象允许读取其中元素，但是不允许向其中存放新的对象_（这个概念也称为数据传送对象，或**信使**）_

基本类型无法作为类型参数。

无论何时，只要你能做到，你就应该尽量使用泛型方法。

当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必致命参数类型，因为编译器会为我们找出具体的类型，这成为**类型参数推断**

在泛型代码内部，无法获得任何有关泛型参数类型的信息。

不能创建泛型数组，一般的解决方案是在任何想要创建泛型数组的地方都使用ArrayList。

###泛型的问题
* 任何基本类型都不能作为类型参数，要使用基本类型的包装器类
* 一个类不能实现同一个泛型接口的两种辩题
* 使用带有泛型类型参数的转型或instanceof不会有任何效果
* 基类劫持了接口

###自限定
```
class A extends SelfBounded<A>
```

自限定可以保证参数类型必须与正在被定义的类相同。

自限定类型的价值在于它们可以产生**协变参数类型**--方法参数类型会随子类而变化。
```
interface Base<T extends Base<T>> {
T get();
}
interface Son extends Base<Sun>{}
public class Test {
    void test(Son s) {
        Son son = s.get();
        Base base = s.get();
    }
}
```

##数组
不能实例化具有参数化类型的数组，**可以参数化数组本身**
```
// 错误！！！
Peel<Banana>[] peels = new Peel<Banana>[10];
// 这个可以
public T[] get(T[] arg) {
    return arg;
} 
Integer[] ints = {1,2,3};
get(ins);
```

###复制数组
```
System.arraycopy();
```
需要的参数是：**源数组**，但是不能执行自动包装和自动拆包，两个数组必须具有相同的确切类型。

###数组比较
```
Arrays.equals(s1,s2);
```

###数组排序
```
Arrays.sort(s1);
```
排序算法针对正排序的特殊类型进行了优化--针对**基本类型**设计的**“快速排序”**，针对对象设计的**“稳定归并排序”**，所以无须担心排序的性能。

##容器深入研究

