# Java编程思想

### Queue

队列是一个典型的**先进先出**的容器。即从容器的一端放入事物，从另一端取出，并且事物放入容器的顺序与取出的顺序是相同的。

LinkedList提供了方法以支持队列的行为，并且它实现了Queue接口，因此LinkedList可以用作Queue的一种实现。

### PriorityQueue
优先级队列声明下一个弹出元素时最需要的元素（具有最高的优先级）。

PriorityQueue可以确保当你调用peek(),poll()和remove()方法时，获取的元素将是队列中优先级最高的元素。

如果要进行**大量的随机访问**，就使用ArrayList；如果要经常**从表中间插入或删除元素**，就是用LinkedList。

新程序不应该使用过时的Vector，Hashtable和Stack。

## 通过异常处理错误
异常处理是Java中唯一正式的错误报告机制，并且通过编译器强制执行。

使用异常的明显好处是，它往往能够降低错误处理代码的复杂度。

## Java标准异常
Throwable对象可分为两种类型：**Error**用来表示编译时和系统错误；**Exception**是可以被抛出的基本类型。

**RuntimeException**是运行时异常，它们会自动被Java虚拟机抛出，所以不必在异常说明中把它们列出来。这些异常都是从RuntimeException类继承而来。它们也被称为**“不受检查异常”**。

只有在你知道如何处理的情况下才捕获异常。

### 异常使用指南
* 在恰当的级别处理问题
* 解决问题并且重新调用产生异常的方法
* 进行少许修补，然后绕过异常发生的地方继续执行
* 用别的数据进行计算，以代替方法预计会返回的值
* 把当前运行环境下能做的事情尽量做完，然后把**相同**的异常重新抛到最高层
* 把当前运行环境下能做的事情尽量做完，然后把**不同**的异常重新抛到更高层
* 终止程序
* 进行简化
* 让类库和程序更安全

## 字符串
###不可变String
String对象是不可变的。String作为方法参数时，实际传递的是引用的一个拷贝。

##类型信息
1. “传统的”RTTI，假定我们在编译时已经知道了所有的类型。
2. “反射”机制，允许我们在运行时发现和使用类的信息。

Java使用Class对象来执行其RTTI（*在运行时，识别一个对象的类型*）

在传递给forName()的字符串中，必须使用**全限定名（包含包名）**

向**Class**引用添加泛型语法的原因_仅仅是为了提供编译期类型检查_。

对instanceof有比较严格的限制：只可将其与命名类型进行比较，而不能与Class对象作比较。

##泛型
###简单泛型
用尖括号括住，放在类名后面
```
public class Holder<T> {
    private T a;
    public void set(T t) {
        this.a = t;
    }
    public T get() {
        return a;
    }
}
```

使用的时候：
```
Holder<Integer> holder= new Holder<Integer>();

int i = 0;

holder.set(i);

i = holder.get();
```

Java泛型的核心概念：**告诉编译器想使用什么类型，然后编译器帮你处理一切细节。**

**元组**，将一组对象直接打包存储于其中的一个单一对象，这个容器对象允许读取其中元素，但是不允许向其中存放新的对象_（这个概念也称为数据传送对象，或**信使**）_

基本类型无法作为类型参数。

无论何时，只要你能做到，你就应该尽量使用泛型方法。

当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必致命参数类型，因为编译器会为我们找出具体的类型，这成为**类型参数推断**

在泛型代码内部，无法获得任何有关泛型参数类型的信息。

不能创建泛型数组，一般的解决方案是在任何想要创建泛型数组的地方都使用ArrayList。

###泛型的问题
* 任何基本类型都不能作为类型参数，要使用基本类型的包装器类
* 一个类不能实现同一个泛型接口的两种辩题
* 使用带有泛型类型参数的转型或instanceof不会有任何效果
* 基类劫持了接口

###自限定
```
class A extends SelfBounded<A>
```

自限定可以保证参数类型必须与正在被定义的类相同。

自限定类型的价值在于它们可以产生**协变参数类型**--方法参数类型会随子类而变化。
```
interface Base<T extends Base<T>> {
T get();
}
interface Son extends Base<Sun>{}
public class Test {
    void test(Son s) {
        Son son = s.get();
        Base base = s.get();
    }
}
```

##数组
不能实例化具有参数化类型的数组，**可以参数化数组本身**
```
// 错误！！！
Peel<Banana>[] peels = new Peel<Banana>[10];
// 这个可以
public T[] get(T[] arg) {
    return arg;
} 
Integer[] ints = {1,2,3};
get(ins);
```

###复制数组
```
System.arraycopy();
```
需要的参数是：**源数组**，但是不能执行自动包装和自动拆包，两个数组必须具有相同的确切类型。

###数组比较
```
Arrays.equals(s1,s2);
```

###数组排序
```
Arrays.sort(s1);
```
排序算法针对正排序的特殊类型进行了优化--针对**基本类型**设计的**“快速排序”**，针对对象设计的**“稳定归并排序”**，所以无须担心排序的性能。

##容器深入研究
###Set
存入Set的每个元素都必须是唯一的，因为Set**不保存重复元素**。加入Set的元素必须定义equals()方法
* HashSet：为快速查找而设计的Set，存入HashSet的元素必须定义hashCode()。
* TreeSet：保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。
* LinkedHashSet：具有HashSet的查询速度，且内部使用链表维护元素的顺序。
如果没有其他的限制，HashSet是默认的选择，因为它对速度进行了优化。

SortedSet中的元素可以保证处于排序状态

###Map
* HashMap：基于散列表的闪现，插入和查询的开销都是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。
* LinkedHashMap：类似HashMap，但迭代遍历时，取得“键值对”的顺序是其插入次序，或者是LRU的次序。迭代访问时比HashMap快。
* TreeMap：基于红黑树的实现。查看“键”或“键值对”时，它们会被排序。所得到的结果是经过排序的。TreeMap是唯一带有subMap()方法的Map。
* WeakHashMap：弱键映射，允许释放映射所指向的对象。
* ConcurrentHashMap：线程安全的Map，不涉及同步加锁。
IdentityHashMap：使用==代替equals()对“键”进行比较的散列映射。

**为了速度而散列**。存储一组元素的最快的数据结构是数组，所以使用它来表示键的信息。数组并不保存键本身，而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码。不同的键可以产生相同的下标，也就是说，可能会有**冲突**。因此，数组多大就不重要了，任何键总能在数组中找到它的位置。

查询一个值的过程首先就是计算散列码，然后使用散列码查询数组，如果保证没有冲突，那就有了一个完美的散列函数。通常，冲突由外部链接处理：数组并不直接保存值，而是保存值的list。然后对list中的值使用equals()方法进行线性的查询。如果散列函数好的话，数组的每个位置就只有较少的值。

散列表中的“槽位”通常称为**桶位**。为使散列分布均匀，桶的数量通常使用**质数**。

散列码不必是独一无二的，应该更关注**生成速度**，而不是唯一性。好的hashCode()应该产生分布均匀的散列码。

HashMap的性能因子
* 容量：表中的桶位数
* 初始容量：表在创建时所拥有的桶位数
* 尺寸：表中当前存储的项数
* 负载因子：尺寸/容量。空表的负载因子是0，而半满表的负载因子是0.5。负载轻的表产生冲突的可能性小，因此对于插入和查找都是最理想的。当负载情况达到该负载因子的水平时，容量将自动增加其容量，实现方式是使容量大致加倍，并重新将现有对象分布到新的桶位集中（**再散列**）

HashMap使用的默认负载因子是0.75，这个因子在时间和空间代价之间达到平衡。

##Java I/O系统

###File类
它既能代表一个特定文件的**名称**，又能代表一个目录下的一组文件的名称。

File类不仅仅只代表存在的文件或目录。也可以用File对象来创建新的目录或尚不存在的整个目录路径。

文件加锁机制允许我们同步访问某个作为共享资源的文件。文件锁对其他的操作系统进程是可见的。

GZIP接口非常简单，因此如果只想对单个数据流进行压缩，那么它可能是非常合适的选择。

Zip可以方便地保存多个文件，它甚至有一个独立的类，使得读取Zip文件更加方便。

Java的**对象序列化**将那些实现了Serializable接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象。

对象的序列化非常有趣，因为利用它可以实现**轻量级持久性**。

对象序列化的概念是为了支持两种主要特性：
* Java的**远程方法调用**，它使存活于其他计算机上的对象使用起来就像存活于本机上一样。
* 对Java Beans来说，对象的序列化也是必需的。

**transient（瞬时）关键字**

我们正在操作的是一个Serializable对象，那么所有序列化操作都会自动进行。为了能够予以控制，可以用**transient关键字**逐个字段地关闭序列化，“不用麻烦保存或恢复数据--我自己处理”。

##枚举类型

除了不能继承自一个enum之外，我们基本上可以将enum看作一个常规的类，可以向enum中添加方法，设置可以有main()方法。

我们可以在switch语句中使用enum。

所有的enum都继承自java.lang.Enum类。由于Java不支持多重继承，所有你的enum不能再继承其他类。所有我们使用接口组织枚举。

EnumSet中的元素必须来自一个enum。EnumMap要求其中的键必须来自一个enum。

##注解

**注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据**

通过使用注解，我们可以将这些元数据保存在Java源代码中，并利用annotation API为自己的注解构造处理工具。

```
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Test{}
```

@Target用来定义你的注解将应用于什么地方（例如是一个方法或者一个域）。@Retention用来定义该注解在哪一个级别可用，在源代码中**（SOURCE）**，类文件中**（CLASS）**，运行时**（RUNTIME）**

没有元素的注解成为**标记注解**，例如上例中的@Test

default值，如果在注解某个方法时没有给出description的值，则该注解的处理器就会使用此元素的默认值。

###元注解

Java目前只内置了三种标准注解，以及四种元注解。元注解专职负责注解其他的注解。
* @Target 表示该注解可以用于什么地方
    * CONSTRUCTOR:构造器的声明
    * FIELD:域声明（包括enum实例）
    * LOCAL_VARIABLE:局部变量声明
    * METHOD:方法声明
    * PACHAGE:包声明
    * PARAMETER:参数声明
    * TYPE：类，接口或enum声明
* @Retention 表示需要在什么级别保存该注解信息
* @Documented 将此注解包含在Javadoc中
* @inherited 允许子类继承父类中的注解

###注解元素
注解元素可用的类型：
* 所有基本类型
* String
* Class
* enum
* Annotation
* 以上类型的数组

注解也可以作为元素的类型，也就是说注解可以嵌套。

###默认值限制

编译器对元素的默认值有些过分挑剔。
* 元素不能有不确定的值。元素必须要么有默认值，要么在使用注解时提供元素的值。
* 对于非基本类型的元素，无论是在源代码中声明时，或是在注解接口中定义默认值时，都不能以null作为其值。

###注解不支持继承

不能使用关键字extends来继承某个@interface。

##并发

并发编程使我们可以将程序划分为多个分离的，独立运行的任务。线程模型为编程带来了便利，简化了在单一程序中同时交织在一起的多个操作的处理。使用线程时，CPU将轮流给每个任务分配其占用时间。每个任务都觉得自己在一直占用CPU，但事实上CPU时间是划分成片段分配给了所有的任务。

###使用Executor

对于shutdown()方法调用可以防止新任务被提交给这个Executor，当前线程将继续运行在shutdown()被调用之前提交的所有任务。

###从任务中产生返回值

Runnable是执行工作的独立任务，但是不返回任何值。如果希望任务在完成时能够返回一个值，可以实现Callable接口，它的类型参数表示的是从方法call()中返回的值，并且必须使用ExecutorService.submit()方法调用它。

submit()方法会产生Future对象，它用Callable返回的结果的特定类型进行了参数化。可以用isDone()方法来查询Future是否已经完成。当任务完成时，它具有一个结果，可以调用get()方法来获取该结果。不用isDone()进行检查就调用get(),这是将阻塞，直至结果准备就绪。

```
class Result implements Callable<String> {
    private int id;
    public Result(int id) {
        this.id = id;
    }
    public String call() {
        return "result is" + id;
    }

public class Demo {
    public static void main(String[] args) {
        ExecutorService exec = Executors.newCacheThreadPool();
           ArrayList<Future<String>> results = new ArrayList<Future<String>>();
       for(int i = 0;i < 10; i++) {
            results.add(exec.submit(new Result(i)));
        }
        for(Future<String> fs : results) {
            try {
                    System.out.println(fs.get());
                } cache(Exception e) {
                } finally {
                     exec.shutdown();
                }
        }
    }
}
```
