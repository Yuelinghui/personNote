##简化函数调用

容易理解和使用的接口，是开发良好面向对象软件的关键。

###Rename Method（函数改名）

函数的名称未能揭示函数的用途，修改函数的名称

####动机

将复杂的处理过程分解成小函数，关键在于给函数起一个好名称。

####做法

* 检查函数签名是否被超类或子类实现过，若是，需要针对每份实现分别进行
* 声明一个新函数，将它命名为你想要的新名称，将旧函数的代码复制到新函数中，并进行适当调整
* 编译
* 修改旧函数，令它将调用转发给新函数
* 编程，测试
* 找出旧函数的所有被引用点，修改它们，令它们改而引用新函数
* 删除旧函数。若旧函数是public接口，将它保留在原处，将它标记为deprecated
* 编译，测试

###Add Parameter（添加参数）

某个函数需要从调用端得到更多信息。为此函数添加一个对象参数，让该对象带进函数所需信息

####动机

必须修改一个函数，而修改后的函数需要一些过去没有的信息，因此你需要给该函数添加一个参数。

####做法

* 检查函数签名是否被超类或子类实现过。若是，则需要针对每份实现进行修改
* 声明一个新函数，名称与源函数相同，只是加上新添参数。将旧函数的代码复制到新函数中。
* 编译
* 修改旧函数，令它调用新函数
* 编译，测试
* 在需要使用新函数的地方使用新函数
* 编译，测试

###Remove Parameter（移除参数）

函数本体不再需要某个参数，将该参数去除

####动机

参数代表着函数所需的信息，不同的参数值有不同的意义。函数调用者必须为每一个参数操心，不去掉多余参数，就是让用户多费一份心，这很不划算。

####做法

* 检查函数签名是否被超类或子类实现过
* 声明一个新函数，名称与原函数相同，去除不必要的参数，将旧函数的代码复制到新函数中
* 编译
* 修改就函数，令它调用新函数
* 编译，测试
* 找出旧函数的所有被引用点，修改为对新函数的引用
* 编译测试
* 删除旧函数
* 编译测试

###Separate Query from Modifier

某个函数既返回对象状态值，又修改对象状态。建立两个不同的函数，其中一个负责查询，另一个负责修改。

####动机

若某个函数只是向你提供一个值，没有任何看得到的副作用，那么可以随意调用这个函数。

**任何有返回值的函数，都不应该有看得到的副作用。**

遇到一个“既有返回值又有副作用”的函数，就应该试着将查询动作从修改动作中分割出来。

####做法

* 新建一个查询函数，令它返回的值与原函数相同
* 修改原函数，令它调用查询函数，并返回获得的结果
* 编译，测试
* 将调用原函数的代码改为调用查询函数。然后，在调用查询函数的那一行之前，加上对原函数的调用
* 编译，测试
* 将原函数的返回值改为void，并删掉其中所有的return语句

若非要在同一个动作中完成检查和赋值，可以用第三个函数来同事做这两件事。

###Parameterize Method（令函数携带参数）

若干函数做了类似的工作，但在函数本体中却包含了不同的值。建立单一函数，以参数表达那些不同的值。

####动机

将各自分离的函数统一起来，并通过参数来处理变化情况，用以简化问题。

这样可以去除重复的代码，并提高灵活性，因为可以用这个参数处理更多的变化情况

####做法

* 新建一个带有参数的函数，使它可以替换先前所有的重复性函数
* 编译
* 将调用旧函数的代码改为调用新函数
* 编译，测试

###Replace Parameter with Explicit Method（以明确函数取代参数）

有一个函数，其中完全取决于参数值而采取不同行为。针对该参数的每一个可能值，建立一个独立函数

####动机

若某个参数有多中可能值，而函数内又以条件表达式检查这些参数值，并根据不同参数值做出不同的行为，就可以这么重构。这样避免出现条件表达式，还可以获得编译期检查的好处，而且接口也更清楚。

若参数值不会对函数行为有太多影响，就不应该使用这个方法。

####做法

* 针对参数的每一种可能值，新建一个明确函数
* 修改条件表达式的每个分支，使其调用合适的新函数
* 修改每个分支后，编译测试
* 修改源函数的每一个被调用点，改为调用上述的某个合适的新函数
* 编译，测试
* 所有调用端都修改完毕后，删除原函数

###Preserve Whole Object（保持对象完整）

从某个对象中取出若干值，将他们作为某一次函数调用时的参数，改为传递整个对象

####动机

将来自同一个对象的若干项数据作为参数，传递给某个函数。万一将来被调用函数需要新的数据项，就必须查找并修改对此函数的所有调用。若把整个对象传给函数，可以避免这个问题。

能提高代码的可读性。过长的参数列很难使用，此外不适用完整对象也会造成重复代码。

应该考量一下对象之间的依赖关系，是否需要使用这个方法

####做法

* 对目标函数新添一个参数项，用以代表原数据所在的完整对象
* 编译，测试
* 判断哪些参数可被包含在新添的完整对象中
* 选择上述参数之一，将被调用函数中原来引用该参数的地方，改为调用新添参数对象的相应取值函数
* 删除该项参数
* 编译，测试
* 针对所有可从对象中获得的参数，重复上述过程
* 删除调用端中那些带有被删除参数的代码
* 编译，测试

###Replace Parameter with Methods（以函数取代参数）

对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。让参数接受者去除该项参数，并直接调用前一个函数

####动机

若函数可以通过其他途径获得参数值，那么它就不应该通过参数取得该值。

####做法

* 若有必要，将参数的计算过程提炼到一个独立函数中
* 将函数本体内引用该参数的地方改为调用新建的函数
* 每次替换后，修改并测试
* 全部替换完成后，使用Remove Parameter将参数去掉

###Introduce Parameter Object（引入参数对象）

某些参数总是很自然地同时出现，以一个对象取代这些参数

####动机

特定的一组参数总是一起被传递，这一组参数就是Data Clumps（数据泥团），可以运用一个对象包装所有这些数据，再以该对象取代它们。

####做法

* 新建一个类，用以表现想替换的一组参数，这个类设为不可变的
* 编译
* 针对使用该组参数的所有函数，实施Add Parameter，传入上述新建类的实例对象
* 对于Data Clumps中的每一项，从函数签名中移除，并修改调用端和函数本体
* 将原先的参数全部去除后，观察有无适当函数可以运用Move Method搬移到参数对象中

###Remove Setting Method

类中某个字段应该在对象创建时被设值，然后就不再改变，去掉该字段的所有设值函数

####动机

为某个字段提供了设值函数，就暗示这个字段值可以被改变，若不希望在对象创建后此字段还有机会被改变，就不要为它提供设值函数

####做法

* 检查设值函数被使用的情况，看它是否只被构造函数调用，或者被构造函数所调用的另一个函数调用
* 修改构造函数，使其世界访问设值函数所针对的那个变量
* 编译，测试
* 移除这个设值函数，将它所针对的字段设为final
* 编译，测试

###Hide Method

有一个函数，从来没有被其他任何类用到，将这个函数修改为private

####动机

当面对一个过于丰富，提供了过多行为的接口时，就值得将非必要的取值函数和设值函数隐藏起来。

####做法

* 经常检查有没有可能降低某个函数的可见度
* 尽可能降低所有函数的可见度
* 每完成一个函数的隐藏之后，编译并测试

###Replace Constructor with Factory Method（以工厂函数取代构造函数）

希望在创建对象时不仅仅是做简单的建构工作，将构造函数替换为工厂函数

####动机

在派生子类的过程中以工厂函数取代类型码。

另外，若构造函数的功能不能满足需要，也可以使用工厂函数来替代它。

####做法

* 新建一个工厂函数，让它调用现有的构造函数
* 将调用构造函数的代码改为调用工厂函数
* 每次替换后，编译并测试
* 将构造函数声明为private
* 编译，测试

通过另一条途径来隐藏子类——使用明确函数。若只有少数几个子类，而且它们都不再变化，就可以在超类中为每个子类定义一个工厂函数

###Encapsulate Downcast（封装向下转型）

某个函数返回的对象，需要由函数调用者执行向下转型，将向下转型动作移到函数中

####动机

若某个函数返回一个值，并且所返回的对象类型比函数所昭告的更特化，便是在函数用户身上强加了非必要的工作。这时，不应该要求用户承担向下转型的责任，应该尽量为他们提供准确的类型

####做法

* 找出必须对函数调用结果进行向下转型的地方
* 将向下转型动过搬移到该函数中

###Replace Error Code with Exception（以异常取代错误码）

某个函数返回一个特性的代码，用以表示某种错误情况，改用异常

####动机

程序发现错误的地方，并不一定知道如何处理错误。当一段子程序发现错误时，它需要让它的调用者知道这个错误，而调用者也可能将这个错误继续沿着调用链传递上去

####做法

* 决定应该抛出受控异常函数非受控异常
* 找到该函数的所有调用者，对它们进行相应调整，让它们使用异常

* 修改该函数的签名，令它反映出新用法

###Replace Exception with Test（以测试取代异常）

面对一个调用者可以预先检查的条件，抛出了一个异常。修改调用者，使它在调用函数之前先做检查

####动机

异常可以协助我们避免很多复杂的错误处理逻辑。但是异常被滥用就不好了。异常只应该被用于异常的，罕见的行为，不应该成为条件检查的替代品

若可以合理期望调用者在调用函数之前先检查某个条件，那就应该提供一个测试，而调用者应该使用它

####做法

* 在函数调用点之前，放置一个测试语句，将函数内catch区段中的代码复制到测试句的适当if分支中
* 在catch区段加入一个断言，确保catch区段绝对不会被执行
* 编译，测试
* 移除try/catch
* 编译，测试

