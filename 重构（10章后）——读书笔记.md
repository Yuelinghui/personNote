##简化函数调用

容易理解和使用的接口，是开发良好面向对象软件的关键。

###Rename Method（函数改名）

函数的名称未能揭示函数的用途，修改函数的名称

####动机

将复杂的处理过程分解成小函数，关键在于给函数起一个好名称。

####做法

* 检查函数签名是否被超类或子类实现过，若是，需要针对每份实现分别进行
* 声明一个新函数，将它命名为你想要的新名称，将旧函数的代码复制到新函数中，并进行适当调整
* 编译
* 修改旧函数，令它将调用转发给新函数
* 编程，测试
* 找出旧函数的所有被引用点，修改它们，令它们改而引用新函数
* 删除旧函数。若旧函数是public接口，将它保留在原处，将它标记为deprecated
* 编译，测试

###Add Parameter（添加参数）

某个函数需要从调用端得到更多信息。为此函数添加一个对象参数，让该对象带进函数所需信息

####动机

必须修改一个函数，而修改后的函数需要一些过去没有的信息，因此你需要给该函数添加一个参数。

####做法

* 检查函数签名是否被超类或子类实现过。若是，则需要针对每份实现进行修改
* 声明一个新函数，名称与源函数相同，只是加上新添参数。将旧函数的代码复制到新函数中。
* 编译
* 修改旧函数，令它调用新函数
* 编译，测试
* 在需要使用新函数的地方使用新函数
* 编译，测试

###Remove Parameter（移除参数）

函数本体不再需要某个参数，将该参数去除

####动机

参数代表着函数所需的信息，不同的参数值有不同的意义。函数调用者必须为每一个参数操心，不去掉多余参数，就是让用户多费一份心，这很不划算。

####做法

* 检查函数签名是否被超类或子类实现过
* 声明一个新函数，名称与原函数相同，去除不必要的参数，将旧函数的代码复制到新函数中
* 编译
* 修改就函数，令它调用新函数
* 编译，测试
* 找出旧函数的所有被引用点，修改为对新函数的引用
* 编译测试
* 删除旧函数
* 编译测试

###Separate Query from Modifier

某个函数既返回对象状态值，又修改对象状态。建立两个不同的函数，其中一个负责查询，另一个负责修改。

####动机

若某个函数只是向你提供一个值，没有任何看得到的副作用，那么可以随意调用这个函数。

**任何有返回值的函数，都不应该有看得到的副作用。**

遇到一个“既有返回值又有副作用”的函数，就应该试着将查询动作从修改动作中分割出来。

####做法

* 新建一个查询函数，令它返回的值与原函数相同
* 修改原函数，令它调用查询函数，并返回获得的结果
* 编译，测试
* 将调用原函数的代码改为调用查询函数。然后，在调用查询函数的那一行之前，加上对原函数的调用
* 编译，测试
* 将原函数的返回值改为void，并删掉其中所有的return语句

若非要在同一个动作中完成检查和赋值，可以用第三个函数来同事做这两件事。

###Parameterize Method（令函数携带参数）

若干函数做了类似的工作，但在函数本体中却包含了不同的值。建立单一函数，以参数表达那些不同的值。

####动机

将各自分离的函数统一起来，并通过参数来处理变化情况，用以简化问题。

这样可以去除重复的代码，并提高灵活性，因为可以用这个参数处理更多的变化情况

####做法

* 新建一个带有参数的函数，使它可以替换先前所有的重复性函数
* 编译
* 将调用旧函数的代码改为调用新函数
* 编译，测试

###Replace Parameter with Explicit Method（以明确函数取代参数）

有一个函数，其中完全取决于参数值而采取不同行为。针对该参数的每一个可能值，建立一个独立函数

####动机

若某个参数有多中可能值，而函数内又以条件表达式检查这些参数值，并根据不同参数值做出不同的行为，就可以这么重构。这样避免出现条件表达式，还可以获得编译期检查的好处，而且接口也更清楚。

若参数值不会对函数行为有太多影响，就不应该使用这个方法。

####做法

* 针对参数的每一种可能值，新建一个明确函数
* 修改条件表达式的每个分支，使其调用合适的新函数
* 修改每个分支后，编译测试
* 修改源函数的每一个被调用点，改为调用上述的某个合适的新函数
* 编译，测试
* 所有调用端都修改完毕后，删除原函数

###Preserve Whole Object（保持对象完整）

从某个对象中取出若干值，将他们作为某一次函数调用时的参数，改为传递整个对象

####动机

将来自同一个对象的若干项数据作为参数，传递给某个函数。万一将来被调用函数需要新的数据项，就必须查找并修改对此函数的所有调用。若把整个对象传给函数，可以避免这个问题。

能提高代码的可读性。过长的参数列很难使用，此外不适用完整对象也会造成重复代码。

应该考量一下对象之间的依赖关系，是否需要使用这个方法

####做法

* 对目标函数新添一个参数项，用以代表原数据所在的完整对象
* 编译，测试
* 判断哪些参数可被包含在新添的完整对象中
* 选择上述参数之一，将被调用函数中原来引用该参数的地方，改为调用新添参数对象的相应取值函数
* 删除该项参数
* 编译，测试
* 针对所有可从对象中获得的参数，重复上述过程
* 删除调用端中那些带有被删除参数的代码
* 编译，测试

###Replace Parameter with Methods（以函数取代参数）

对象调用某个函数，并将所得结果作为参数，传递给另一个函数。而接受该参数的函数本身也能够调用前一个函数。让参数接受者去除该项参数，并直接调用前一个函数

####动机

若函数可以通过其他途径获得参数值，那么它就不应该通过参数取得该值。

####做法

* 若有必要，将参数的计算过程提炼到一个独立函数中
* 将函数本体内引用该参数的地方改为调用新建的函数
* 每次替换后，修改并测试
* 全部替换完成后，使用Remove Parameter将参数去掉

###Introduce Parameter Object（引入参数对象）

某些参数总是很自然地同时出现，以一个对象取代这些参数

####动机

特定的一组参数总是一起被传递，这一组参数就是Data Clumps（数据泥团），可以运用一个对象包装所有这些数据，再以该对象取代它们。

####做法

* 新建一个类，用以表现想替换的一组参数，这个类设为不可变的
* 编译
* 针对使用该组参数的所有函数，实施Add Parameter，传入上述新建类的实例对象
* 对于Data Clumps中的每一项，从函数签名中移除，并修改调用端和函数本体
* 将原先的参数全部去除后，观察有无适当函数可以运用Move Method搬移到参数对象中

